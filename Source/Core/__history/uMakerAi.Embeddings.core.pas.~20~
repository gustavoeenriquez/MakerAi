unit uMakerAi.Embeddings.core;

interface

uses
  System.SysUtils, System.Types, System.Classes, System.Generics.Collections, System.Generics.Defaults,
  System.JSON;

type
  // Definición del tipo para el vector de embedding
  TAiEmbeddingData = TArray<Double>;
  TAiEmbeddingList = TArray<TAiEmbeddingData>;

  TAiSimilarityResult = record
    Index: Integer;       // El índice del vector en la lista original
    Score: Double;        // La puntuación de similitud (e.g., similitud coseno)
    Vector: TAiEmbeddingData; // Opcional: el vector encontrado
  end;

  TAiSimilarityList = TArray<TAiSimilarityResult>;


  // Declaración del nuevo tipo de evento
  TOnGetEmbedding = procedure(Sender: TObject;
    const aInput, aUser, aModel, aEncodingFormat: String;
    aDimensions: Integer; var aEmbedding: TAiEmbeddingData) of object;

  // Clase base TAiEmbeddingsCore
  TAiEmbeddingsCore = class(TComponent)
  private
    FOnGetEmbedding: TOnGetEmbedding;
    procedure SetData(const Value: TAiEmbeddingData);
  protected
    FData: TAiEmbeddingData;
    FModel: String;
    FDimensions: Integer;
    Ftotal_tokens: Integer;
    Fprompt_tokens: Integer;
  public
    constructor Create(aOwner: TComponent); override;


    function CreateEmbedding(aInput, aUser: String; aDimensions: Integer = -1;   aModel: String = ''; aEncodingFormat: String = 'float') : TAiEmbeddingData; virtual;
    // Métodos de utilidad que no dependen de una API externa
    function ToJsonArray: TJsonArray; overload;
    class function ToJsonArray(Val: TAiEmbeddingData): TJsonArray; overload;
    class function ToEmbeddingData(Value : TJSonArray) : TAiEmbeddingData;
    class function Magnitude(const V: TAiEmbeddingData): Double;
    class function DotProduct(const A, B: TAiEmbeddingData): Double;
    class function CosineSimilarity(const A, B: TAiEmbeddingData): Double;
    class function EuclideanDistance(const A, B: TAiEmbeddingData): Double;
    class procedure Normalize(var V: TAiEmbeddingData);
    class function FindNearest(const Query: TAiEmbeddingData; const Candidates: TAiEmbeddingList): TAiSimilarityResult;
    class function FindTopK(const Query: TAiEmbeddingData;  const Candidates: TAiEmbeddingList; K: Integer): TAiSimilarityList;
    class function VectorAdd(const A, B: TAiEmbeddingData): TAiEmbeddingData;
    class function VectorSubtract(const A, B: TAiEmbeddingData): TAiEmbeddingData;

    property Data: TAiEmbeddingData read FData write SetData;
  published
    property Model: String read FModel write FModel;
    property Dimensions: Integer read FDimensions write FDimensions;
    property prompt_tokens: Integer read Fprompt_tokens;
    property total_tokens: Integer read Ftotal_tokens;

    // El evento que permitirá la implementación personalizada
    property OnGetEmbedding: TOnGetEmbedding read FOnGetEmbedding write FOnGetEmbedding;
  end;

implementation

{ TAiEmbeddingsCore }

constructor TAiEmbeddingsCore.Create(aOwner: TComponent);
begin
  inherited Create(aOwner);
  // Valores por defecto genéricos
  FDimensions := 1536;
  FModel := 'custom-model';
end;

function TAiEmbeddingsCore.CreateEmbedding(aInput, aUser: String; aDimensions: Integer; aModel, aEncodingFormat: String): TAiEmbeddingData;
var
  LModel: String;
  LDimensions: Integer;
begin
  // Si no se asignó el evento, no se puede hacer nada.
  if not Assigned(FOnGetEmbedding) then
    raise Exception.Create('El evento OnGetEmbedding no ha sido asignado. No se puede generar el embedding.');

  // Usar los parámetros si se proporcionan, si না los de la propiedad
  if aModel <> '' then LModel := aModel else LModel := Self.FModel;
  if aDimensions > 0 then LDimensions := aDimensions else LDimensions := Self.FDimensions;

  // Limpiar el resultado anterior
  SetLength(Result, 0);

  // Invocar el evento para que el usuario genere el embedding
  FOnGetEmbedding(Self, aInput, aUser, LModel, aEncodingFormat, LDimensions, Result);

  // Guardar el resultado en la propiedad Data y retornarlo
  Self.FData := Result;
end;

procedure TAiEmbeddingsCore.SetData(const Value: TAiEmbeddingData);
begin
  FData := Value;
end;

class function TAiEmbeddingsCore.Magnitude(const V: TAiEmbeddingData): Double;
var
  Sum: Double;
  i: Integer;
begin
  Sum := 0.0;
  for i := Low(V) to High(V) do
    Sum := Sum + Sqr(V[i]);
  Result := Sqrt(Sum);
end;

class procedure TAiEmbeddingsCore.Normalize(var V: TAiEmbeddingData);
var
  mag: Double;
  i: Integer;
begin
  mag := Magnitude(V);
  if mag = 0 then Exit; // No se puede normalizar un vector nulo

  for i := 0 to High(V) do
    V[i] := V[i] / mag;
end;

class function TAiEmbeddingsCore.DotProduct(const A, B: TAiEmbeddingData): Double;
var
  i: Integer;
begin
  Result := 0.0;
  // Se asume que A y B tienen la misma longitud
  for i := Low(A) to High(A) do
    Result := Result + A[i] * B[i];
end;

class function TAiEmbeddingsCore.EuclideanDistance(const A, B: TAiEmbeddingData): Double;
var
  i: Integer;
  SumOfSquares: Double;
begin
  if Length(A) <> Length(B) then
    raise Exception.Create('Los vectores deben tener la misma dimensión.');

  SumOfSquares := 0.0;
  for i := 0 to High(A) do
    SumOfSquares := SumOfSquares + Sqr(A[i] - B[i]); // Sqr es (x * x)

  Result := Sqrt(SumOfSquares);
end;

class function TAiEmbeddingsCore.FindNearest(const Query: TAiEmbeddingData; const Candidates: TAiEmbeddingList): TAiSimilarityResult;
var
  i: Integer;
  bestScore: Double;
  currentScore: Double;
begin
  if Length(Candidates) = 0 then
    raise Exception.Create('La lista de candidatos no puede estar vacía.');

  bestScore := -2.0; // Iniciar con un valor inferior a cualquier posible similitud coseno (-1 a 1)
  Result.Index := -1;

  for i := 0 to High(Candidates) do
  begin
    currentScore := CosineSimilarity(Query, Candidates[i]);
    if currentScore > bestScore then
    begin
      bestScore := currentScore;
      Result.Index := i;
      Result.Score := currentScore;
    end;
  end;

  if Result.Index <> -1 then
    Result.Vector := Candidates[Result.Index];
end;

class function TAiEmbeddingsCore.FindTopK(const Query: TAiEmbeddingData; const Candidates: TAiEmbeddingList; K: Integer): TAiSimilarityList;
var
  AllResults: TList<TAiSimilarityResult>;
  i: Integer;
  aResult: TAiSimilarityResult;
begin
  AllResults := TList<TAiSimilarityResult>.Create;
  try
    for i := 0 to High(Candidates) do
    begin
      aResult.Index := i;
      aResult.Score := CosineSimilarity(Query, Candidates[i]);
      aResult.Vector := Candidates[i];
      AllResults.Add(aResult);
    end;

    // Ordenar la lista de resultados por puntuación en orden descendente
    AllResults.Sort(TComparer<TAiSimilarityResult>.Construct(
      function(const L, R: TAiSimilarityResult): Integer
      begin
        if L.Score > R.Score then Result := -1
        else if L.Score < R.Score then Result := 1
        else Result := 0;
      end
    ));

    // Devolver los primeros K resultados
    if K > AllResults.Count then K := AllResults.Count;
    Result := Copy(AllResults.ToArray, 0, K);

  finally
    AllResults.Free;
  end;
end;

class function TAiEmbeddingsCore.CosineSimilarity(const A, B: TAiEmbeddingData): Double;
var
  MagA, MagB: Double;
begin
  MagA := Magnitude(A);
  MagB := Magnitude(B);
  if (MagA = 0) or (MagB = 0) then
    Result := 0 // Para evitar división por cero
  else
    Result := DotProduct(A, B) / (MagA * MagB);
end;

class function TAiEmbeddingsCore.ToEmbeddingData(Value: TJSonArray): TAiEmbeddingData;
Var
  J : Integer;
begin
    J := Value.Count;
    SetLength(Result, J);
    For J := 0 to Value.Count - 1 do
      Result[J] := Value.Items[J].GetValue<Double>;
end;

class function TAiEmbeddingsCore.ToJsonArray(Val: TAiEmbeddingData): TJsonArray;
var
  i: Integer;
begin
  Result := TJsonArray.Create;
  for i := 0 to Length(Val) - 1 do
    Result.Add(Val[i]);
end;

class function TAiEmbeddingsCore.VectorAdd(const A, B: TAiEmbeddingData): TAiEmbeddingData;
var
  i: Integer;
begin
  if Length(A) <> Length(B) then
    raise Exception.Create('Los vectores deben tener la misma dimensión.');

  SetLength(Result, Length(A));
  for i := 0 to High(A) do
    Result[i] := A[i] + B[i];
end;

function TAiEmbeddingsCore.ToJsonArray: TJsonArray;
begin
  Result := ToJsonArray(Self.FData);
end;

end.

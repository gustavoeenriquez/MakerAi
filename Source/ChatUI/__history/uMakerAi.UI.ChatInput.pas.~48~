unit uMakerAi.UI.ChatInput;

interface

uses
  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,
  System.IOUtils, System.Net.HttpClient, System.NetEncoding, System.Rtti, System.Net.URLClient,
  System.AnsiStrings, System.Math, System.Threading, System.Generics.Collections,
  uMakerAi.Chat, uMakerAi.Core, uMakerAi.Chat.AiConnection,

  {}

  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Memo.Types,
  FMX.Platform, FMX.Surfaces, FMX.MultiResBitmap, FMX.Styles.Objects,
  FMX.Layouts, FMX.ScrollBox, FMX.Memo, FMX.Objects,
  FMX.Controls.Presentation, FMX.StdCtrls, FMX.ListBox, System.ImageList,
  FMX.ImgList, System.Actions, FMX.ActnList, FMX.Menus, uMakerAi.Utils.VoiceMonitor;

type

  TChatSendEvent = Procedure(Sender: TObject; APrompt: String; aMediaFiles: TAiMediaFiles; aAudioStream: TMemoryStream) of Object;
  TChatTranscriptEvent = Procedure(Sender: TObject; aFragmentStream: TMemoryStream; Out aTransriptText: String) of Object;

  TImageStatus = (isInactivo, isPreparing, isListening, isUserTalking, isIaTalking);
  TContentType = (ctImage, ctPDF, ctAudio, ctVideo, ctDocument, ctText, ctUnknown);

  TImageData = Class
    FileName: String;
    Checked: TCheckBox;
    Item: TLayout;
    BitMap: TBitMap;
    Stream: TMemoryStream;
  End;

  TChatInput = class(TLayout)
    FChatLayout: TRectangle;
    FLayout1: TLayout;
    FLayout2: TLayout;
    FLayoutSend: TLayout;
    FBtnMenu: TCornerButton;
    FBtnMic: TCornerButton;
    FBtnSend: TCornerButton;
    FMemoPrompt: TMemo;
    FImageLayout: TFlowLayout;
    FImage1: TImage;
    FBtnSound: TCornerButton;
    FImage3: TImage;
    FImage4: TImage;
    FImageList1: TImageList;
    FImageListVoice: TImageList;
    FLblStatus: TLabel;
    FProgressBarLevel: TProgressBar;
    FImageBtnSend: TImage;
    FImageBtnSound: TImage;
    FImageBtnMenu: TImage;
    FImageBtnMic: TImage;

    procedure DocsDragDrop(Sender: TObject; const Data: TDragObject; const Point: TPointF);
    procedure DocsDragOver(Sender: TObject; const Data: TDragObject; const Point: TPointF; var Operation: TDragOperation);
    procedure BtnMenuClick(Sender: TObject);
    procedure ac_pasteExecute(Sender: TObject);
    procedure ac_UploadFileExecute(Sender: TObject);
    procedure ac_ScreenShotExecute(Sender: TObject);
    procedure ac_ClearExecute(Sender: TObject);
    procedure ac_pasteUpdate(Sender: TObject);
    procedure MemoPromptChange(Sender: TObject);
    procedure Timer1Timer(Sender: TObject);
    procedure MenuItem2Click(Sender: TObject);
    procedure BtnSendClick(Sender: TObject);
    procedure MemoPromptKeyUp(Sender: TObject; var Key: Word; var KeyChar: WideChar; Shift: TShiftState);
    procedure AnimationTimerTimer(Sender: TObject);
    procedure BtnMicClick(Sender: TObject);
    procedure AIVoiceMonitorCalibrated(Sender: TObject; const aNoiseLevel, aSensitivity, aStopSensitivity: Integer);
    procedure AIVoiceMonitorChangeState(Sender: TObject; aUserSpeak, aIsValidForIA: Boolean; aStream: TMemoryStream);
    procedure AIVoiceMonitorError(Sender: TObject; const ErrorMessage: string);
    procedure AIVoiceMonitorUpdate(Sender: TObject; const aSoundLevel: Int64);
    procedure AIVoiceMonitorWakeWordCheck(Sender: TObject; aWakeWordStream: TMemoryStream; var IsValid: Boolean);
    procedure AIVoiceMonitorTranscriptionFragment(Sender: TObject; aFragmentStream: TMemoryStream);
    procedure AIVoiceMonitorSpeechEnd(Sender: TObject; aIsValidForIA: Boolean; aStream: TMemoryStream);
  private
    FFont: TFont;
    FOnCancel: TNotifyEvent;
    FBusy: Boolean;

    FSendBitmap: TBitMap;
    FCancelBitmap: TBitMap;

    procedure SetFont(const Value: TFont);
    procedure SetOnCancel(const Value: TNotifyEvent);
    procedure SetBusy(const Value: Boolean);

  Protected
    FImagesVisible: Boolean;
    FInitialMemoHeight: Single;
    FInitialFrameHeight: Single;
    FInitialHeightsCaptured: Boolean;
    FTimer: TTimer;
    FAnimationTimer: TTimer;
    FOnSendEvent: TChatSendEvent;
    FMicVisible: Boolean;
    FSoundVisible: Boolean;

    // Variables del SoundMonitor
    FCurrentSoundLevel: Integer;
    FMaxLevelSeen: Integer; // Resetear el máximo para que la barra se ajuste
    // FProgressBarLevel: TSoundLevel;
    FUseSoundMonitor: Boolean;
    FOnTranscriptText: TChatTranscriptEvent;
    FWakeWordDetectedInSession: Boolean;
    FProcessingMode: (pmSendFullText, pmSendLastAudio);
    FValidExtensions: String;
    FVoiceMonitor: TAIVoiceMonitor;
    FMenu: TPopupMenu;

    FMnuPaste: TMenuItem;
    FMnuClear: TMenuItem;

    procedure LoadImageResources; // Nuevo procedimiento para cargar imágenes
    procedure CreateInternalControls; // Nuevo para crear la UI
    procedure Resize; Override;
    procedure Loaded; override;

    procedure UpdateChatLayoutHeight;
    function ScaleRectangle(MaxSize: Double; X, Y: Double; var ScaledX, ScaledY: Double): Boolean;
    Procedure PasteFromClipBoard;
    Procedure LoadFromFile;
    Procedure ScreenCapture;
    Procedure ClearSlides;
    Function DownLoadFromUrl(sUrl: String): TMemoryStream;
    procedure SetImagesVisible(const Value: Boolean);
    procedure SetOnSendEvent(const Value: TChatSendEvent);
    Procedure DoSendEvent(aAudioFile: TMemoryStream);
    Procedure DoTranscriptText(aFragmentStream: TMemoryStream; Out aTransriptText: String);
    procedure SetMicVisible(const Value: Boolean);
    procedure SetSoundVisible(const Value: Boolean);
    Procedure StartMonitoring;
    Procedure StopMonitoring;
    Procedure ActiveSoundMonitor(AStatus: Boolean);
    procedure SetUseSoundMonitor(const Value: Boolean);
    procedure SetOnTranscriptText(const Value: TChatTranscriptEvent);
    function IsValidFileExtension(const Extension: string): Boolean;

    function GetContentTypeFromData(const Data: TBytes): TContentType;
    function GetContentTypeFromText(const Text: string): TContentType;
    function GetImageIndexFromContentType(ContentType: TContentType): Integer;
    function CreateBitmapFromImageList(ImageIndex: Integer): TBitMap;
    function GetContentTypeFromValidExtensions(const Extension: string): TContentType;
    procedure SetValidExtensions(const Value: String);
    function BuildFileDialogFilter: string;
    procedure SetVoiceMonitor(const Value: TAIVoiceMonitor);
    Procedure DeleteSlideItem(ItemToDelete: TFMXObject);
    procedure OnSlideItemDelete(Sender: TObject);
    Procedure InitPopupMenu;
    Function LoadImageFromResource(ABitmap: TBitMap; const ResourceName: string): Boolean;
    function AddBitmapToImageList(ABitmap: TBitMap; ImageList: TImageList; const ItemName: string = ''): Integer;
    procedure FontChanged(Sender: TObject);
    Procedure RecalcLayoutSend;
    Procedure SetMicImageStatus(IdImage : Integer);

  public
    constructor Create(AOwner: TComponent); override;
    Destructor Destroy; Override;
    Procedure AddImageToSlide(FileName: String; BitMap: TBitMap; aStream: TMemoryStream);
    Procedure AddStatus(Msg: String);
  Published
    Property ImagesVisible: Boolean read FImagesVisible write SetImagesVisible;
    Property MicVisible: Boolean read FMicVisible write SetMicVisible;
    Property SoundVisible: Boolean read FSoundVisible write SetSoundVisible;
    Property UseSoundMonitor: Boolean read FUseSoundMonitor write SetUseSoundMonitor;
    Property ValidExtensions: String read FValidExtensions write SetValidExtensions;
    Property VoiceMonitor: TAIVoiceMonitor read FVoiceMonitor write SetVoiceMonitor;
    Property Font: TFont read FFont write SetFont;
    Property OnSendEvent: TChatSendEvent read FOnSendEvent write SetOnSendEvent;
    Property OnTranscriptText: TChatTranscriptEvent read FOnTranscriptText write SetOnTranscriptText;
    Property OnCancel: TNotifyEvent read FOnCancel write SetOnCancel;
    Property Busy: Boolean read FBusy write SetBusy;
  end;

var
  ChatInputFrame: TChatInput;

const
  IMAGE_WIDTH = 50;
  MAX_MEMO_HEIGHT = 200;
  MIN_FRAME_HEIGHT = 60;

  IMG_INDEX_IMAGE = 4;
  IMG_INDEX_PDF = 5;
  IMG_INDEX_AUDIO = 6;
  IMG_INDEX_VIDEO = 7;
  IMG_INDEX_DOCUMENT = 8;
  IMG_INDEX_TEXT = 9;
  IMG_INDEX_UNKNOWN = 10;

procedure Register;

implementation

uses uMakerAi.Utils.ScreenCapture;

procedure Register;
begin
  RegisterComponents('MakerAI UI', [TChatInput]);
end;

{ TChatInput }

constructor TChatInput.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);

  // --- 1. Inicializar propiedades y variables de estado ---
  FImagesVisible := False;
  FValidExtensions := 'jpg,jpeg,png,bmp,pdf,mp3,wav,mp4,avi';
  FWakeWordDetectedInSession := False;
  Width := 400; // Un ancho por defecto razonable
  Height := MIN_FRAME_HEIGHT;; // Una altura inicial mínima

  // --- 2. Crear y cargar los ImageLists desde recursos ---
  FImageList1 := TImageList.Create(Self);
  FImageListVoice := TImageList.Create(Self);

  CreateInternalControls;

  LoadImageResources; // Llama al nuevo método para poblar los ImageLists

  FSendBitmap := TBitMap.Create;
  FCancelBitmap := TBitMap.Create;

  LoadImageFromResource(FSendBitmap, 'BTN_SEND_PNG');
  LoadImageFromResource(FCancelBitmap, 'IMG_CANCEL_PNG');
  FImageBtnSend.BitMap.Assign(FSendBitmap);

  FFont := TFont.Create;
  FFont.OnChanged := FontChanged;

  // --- 3. Crear toda la interfaz de usuario interna ---

  // --- 4. Crear timers y objetos de lógica ---
  FTimer := TTimer.Create(Self);
  FTimer.Enabled := False;
  FTimer.Interval := 1;
  FTimer.OnTimer := Timer1Timer;

  FAnimationTimer := TTimer.Create(Self);
  FAnimationTimer.Interval := 50;
  FAnimationTimer.OnTimer := AnimationTimerTimer;
  FAnimationTimer.Enabled := True; // Inicia deshabilitado si no se usa

  // --- 5. LÓGICA CLAVE: Crear objetos que no deben ser "streameados" ---
  // El PopupMenu y sus items se crean aquí solo si el componente no está
  // siendo cargado desde un DFM. Esto evita conflictos con el streaming.
  FMenu := Nil;
  InitPopupMenu;

end;

procedure TChatInput.ActiveSoundMonitor(AStatus: Boolean);
begin
  If AStatus = True then
    StopMonitoring
  Else
    StartMonitoring;
end;

procedure TChatInput.ac_ClearExecute(Sender: TObject);
begin
  ClearSlides;
end;

procedure TChatInput.ac_pasteExecute(Sender: TObject);
begin
  PasteFromClipBoard;
end;

procedure TChatInput.ac_pasteUpdate(Sender: TObject);
var
  ClipboardService: IFMXClipboardService;
  HasContent: Boolean;
  ClipboardValue: TValue;
begin
  HasContent := False;

  if TPlatformServices.Current.SupportsPlatformService(IFMXClipboardService, IInterface(ClipboardService)) then
  begin
    try
      // Verificar si el servicio de clipboard está disponible y asignado
      if Assigned(ClipboardService) then
      begin
        ClipboardValue := ClipboardService.GetClipboard;

        // Verificar si hay contenido válido en el clipboard
        if not ClipboardValue.IsEmpty then
        begin
          case ClipboardValue.Kind of
            tkString, tkWString, tkUString:
              begin
                // Hay texto en el clipboard
                HasContent := ClipboardValue.AsString.Trim <> '';
              end;
            tkClass:
              begin
                // Hay un objeto en el clipboard (posiblemente una imagen)
                if (ClipboardValue.AsObject <> nil) and (ClipboardValue.AsObject is TBitMapSurface) then
                  HasContent := True;
              end;
            tkVariant:
              begin
                // Contenido variant (puede ser imagen u otros tipos)
                HasContent := not VarIsEmpty(ClipboardValue.AsVariant);
              end;
          end;
        end;
      end;
    except
      // En caso de error al acceder al clipboard
      HasContent := False;
    end;
  end;

  // Habilitar o deshabilitar la acción según si hay contenido
  FMnuPaste.Enabled := HasContent;
end;

procedure TChatInput.ac_ScreenShotExecute(Sender: TObject);
begin
  ScreenCapture;
end;

procedure TChatInput.ac_UploadFileExecute(Sender: TObject);
begin
  LoadFromFile;
end;

function TChatInput.AddBitmapToImageList(ABitmap: TBitMap; ImageList: TImageList; const ItemName: string): Integer;
var
  SourceItem: TSourceItem;
  DestinationItem: TDestinationItem;
  FinalName: string;
begin
  Result := -1;

  if not Assigned(ABitmap) or not Assigned(ImageList) then
    Exit;

  try
    // Generar nombre si no se proporciona
    if ItemName = '' then
      FinalName := 'Item_' + IntToStr(ImageList.Source.Count)
    else
      FinalName := ItemName;

    // Agregar la imagen al Source del ImageList
    SourceItem := TSourceItem(ImageList.Source.Add);
    SourceItem.MultiResBitmap.Add;
    SourceItem.MultiResBitmap.Items[0].BitMap.Assign(ABitmap);
    SourceItem.Name := FinalName;

    // Agregar un destination item que mapee a este source
    DestinationItem := TDestinationItem(ImageList.Destination.Add);
    DestinationItem.Layers.Add;
    DestinationItem.Layers[0].SourceRect.Rect := RectF(0, 0, ABitmap.Width, ABitmap.Height);
    DestinationItem.Layers[0].Name := FinalName;
    // DestinationItem.Name := FinalName + '_Dest';

    // Retornar el índice del item agregado
    Result := ImageList.Source.Count - 1;

  except
    on E: Exception do
    begin
      ShowMessage('Error agregando bitmap al ImageList: ' + E.Message);
      Result := -1;
    end;
  end;
end;

procedure TChatInput.AddImageToSlide(FileName: String; BitMap: TBitMap; aStream: TMemoryStream);
Var
  X, Y, X1, Y1: Double;
  Image: TImage;
  Check: TCheckBox;
  Item: TLayout;
  ImageData: TImageData;
  btnDelete: TSpeedButton;

begin
  X := BitMap.Width;
  Y := BitMap.Height;
  ScaleRectangle(150, X, Y, X1, Y1);

  Image := TImage.Create(Self);
  Image.BitMap := BitMap.CreateThumbnail(Trunc(X1), Trunc(Y1));
  Image.Align := TAlignLayout.Contents;
  Image.WrapMode := TImageWrapMode.Fit;
  Image.Margins := TBounds.Create(TRectf.Create(2, 2, 2, 2));
  Image.HitTest := False;

  Check := TCheckBox.Create(Self);
  Check.Align := TAlignLayout.Bottom;
  Check.Text := ExtractFileName(FileName);
  Check.IsChecked := True;
  Check.Opacity := 0.4;
  Check.Visible := False; // Esta se oculta por ahora

  btnDelete := TSpeedButton.Create(Self);
  btnDelete.Width := 15;
  btnDelete.Height := 15;
  btnDelete.Margins.Top := 2;
  btnDelete.Margins.Right := 2;
  btnDelete.Position.X := IMAGE_WIDTH - btnDelete.Width;
  btnDelete.Position.Y := 0;
  btnDelete.Text := 'X';
  btnDelete.OnClick := OnSlideItemDelete;

  Item := TLayout.Create(Self);
  Item.AddObject(Image);
  Item.AddObject(Check);
  Item.AddObject(btnDelete);

  Item.Width := IMAGE_WIDTH;
  Item.Height := IMAGE_WIDTH;

  ImageData := TImageData.Create;
  ImageData.FileName := FileName;
  ImageData.Checked := Check;
  ImageData.Item := Item;
  ImageData.BitMap := BitMap;
  ImageData.Stream := aStream;

  Item.TagObject := ImageData;

  FImageLayout.AddObject(Item);
  ImagesVisible := FImageLayout.ChildrenCount > 0;

  btnDelete.TagObject := Item;

  // btnDelete.StyleLookup := 'deletetoolbutton';
  // btnDelete.ApplyStyleLookup;

end;

procedure TChatInput.AddStatus(Msg: String);
begin
  TThread.Queue(nil,
    procedure
    begin
      FLblStatus.Text := 'Status: ' + Msg;
    end);
end;

procedure TChatInput.AIVoiceMonitorCalibrated(Sender: TObject; const aNoiseLevel, aSensitivity, aStopSensitivity: Integer);
begin
  AddStatus('Escuchando...');

  SetMicImageStatus(Integer(TImageStatus.isListening));
  //FBtnMic.ImageIndex := Integer(TImageStatus.isListening);
end;

procedure TChatInput.AIVoiceMonitorChangeState(Sender: TObject; aUserSpeak, aIsValidForIA: Boolean; aStream: TMemoryStream);
begin
  if aUserSpeak then
  begin
    // El monitor ha detectado que el usuario ha empezado a hablar.
  SetMicImageStatus(Integer(TImageStatus.isUserTalking));
    //FBtnMic.ImageIndex := Integer(TImageStatus.isUserTalking);
    AddStatus('usuario hablando...');
  end
  else
  begin
    // El monitor ha detectado silencio y ha terminado la grabación.
  SetMicImageStatus(Integer(TImageStatus.isListening));
    //FBtnMic.ImageIndex := Integer(TImageStatus.isListening);
    AddStatus('Escuchando...');
  end;
end;

procedure TChatInput.AIVoiceMonitorError(Sender: TObject; const ErrorMessage: string);
begin
  // MemoLog.Lines.Add('ERROR: ' + ErrorMessage);
  AddStatus('Error-' + ErrorMessage);
  ShowMessage('Ocurrió un error en el monitor de audio: ' + sLineBreak + ErrorMessage);
  StopMonitoring;
end;

procedure TChatInput.AIVoiceMonitorSpeechEnd(Sender: TObject; aIsValidForIA: Boolean; aStream: TMemoryStream);
Var
  Res: String;
begin

  // Aquí está la lógica clave: solo procesamos el audio completo si la palabra de activación fue validada.
  if aIsValidForIA then
  begin

    DoTranscriptText(aStream, Res);

    TThread.Queue(nil,
      procedure
      begin
        FMemoPrompt.BeginUpdate;
        Try
          FMemoPrompt.Lines.Text := FMemoPrompt.Lines.Text + Res + ' ';
          FMemoPrompt.GoToTextEnd;
        Finally
          FMemoPrompt.EndUpdate;
          //Application.ProcessMessages;
        End;

        DoSendEvent(aStream);
      end);
  end
  else
  begin
    // En caso que no se utilice el WakeWord
  end;

  FWakeWordDetectedInSession := False;

end;

procedure TChatInput.AIVoiceMonitorTranscriptionFragment(Sender: TObject; aFragmentStream: TMemoryStream);
begin

  if FBusy then
    Exit; // Si estamos enviando, ignora nuevos fragmentos de voz

  TTask.Run(
    procedure
    var
      Res: String;
    begin
      try
        try
          DoTranscriptText(aFragmentStream, Res);
          If Trim(Res) <> '' then
          Begin

            TThread.Queue(nil,
              procedure
              begin

                FMemoPrompt.BeginUpdate;
                Try
                  FMemoPrompt.Lines.Text := FMemoPrompt.Lines.Text + Res + ' ';
                  FMemoPrompt.GoToTextEnd;
                Finally
                  FMemoPrompt.EndUpdate;
                  Application.ProcessMessages;
                End;
              end);

          End;
        except
          on E: Exception do
          begin
            TThread.Queue(nil,
              procedure
              begin
                // Aquí puedes mostrar el error o manejarlo
              end);
          end;
        end;
      finally
      end;
    end);
end;

procedure TChatInput.AIVoiceMonitorUpdate(Sender: TObject; const aSoundLevel: Int64);
begin
  FCurrentSoundLevel := aSoundLevel;
end;

procedure TChatInput.AIVoiceMonitorWakeWordCheck(Sender: TObject; aWakeWordStream: TMemoryStream; var IsValid: Boolean);
Var
  Res: String;
Begin
  IsValid := False;
  DoTranscriptText(aWakeWordStream, Res);
  Res := Trim(LowerCase(Res));

  If Res <> '' then
  Begin
    IsValid := Res.Contains(Trim(LowerCase(FVoiceMonitor.WakeWord)));
    FWakeWordDetectedInSession := IsValid;
  End;
end;

procedure TChatInput.AnimationTimerTimer(Sender: TObject);
const
  SMOOTHING_FACTOR = 0.2;
  PBST_NORMAL = 1;
  PBST_ERROR = 2;
  PBST_PAUSED = 3;
var
  CurrentPos, TargetPos, NewPos: Double;
  StateStr: string;
begin

  If FMemoPrompt.StyleLookup <> 'memostyle' then
  Begin

    if csDesigning in ComponentState then
      Exit;

    // Elimina el fondo blanco del memo y el borde
    FMemoPrompt.StyleLookup := 'memostyle';
    FMemoPrompt.ApplyStyleLookup;

    Var
    StyleObj := FMemoPrompt.FindStyleResource('background');
    if (StyleObj <> nil) and (StyleObj is TActiveStyleObject) then
    begin
      TActiveStyleObject(StyleObj).Opacity := 0;
    end;
  End;

  If Not Assigned(FVoiceMonitor) then
    Exit;

  if FVoiceMonitor.Active then
    TargetPos := FCurrentSoundLevel
  else
    TargetPos := 0;

  if TargetPos > FProgressBarLevel.Max then
    FProgressBarLevel.Max := Round(TargetPos * 1.2); // Dar un margen

  CurrentPos := FProgressBarLevel.Value;
  NewPos := CurrentPos + Round((TargetPos - CurrentPos) * SMOOTHING_FACTOR);
  FProgressBarLevel.Value := Round(Min(NewPos, FProgressBarLevel.Max));

  case FVoiceMonitor.State of
    msCalibrating:
      StateStr := 'Calibrando...';
    msMonitoring:
      StateStr := 'Monitorizando';
    msRequestingPermission:
      StateStr := 'Pidiendo permiso...';
    msError:
      StateStr := 'Error';
  else
    StateStr := 'Inactivo';
  end;
end;

procedure TChatInput.BtnMenuClick(Sender: TObject);
var
  Pt: TPointF;
  Obj: IControl;
begin

  if TControl(Sender).GetInterface(IControl, Obj) then
  begin
    Pt := TControl(Sender).LocalToScreen(TPointF.Create(TControl(Sender).Width, 0));
    Obj.ShowContextMenu(Pt);
  end;

end;

procedure TChatInput.BtnMicClick(Sender: TObject);
begin
  UseSoundMonitor := Not UseSoundMonitor;
end;

procedure TChatInput.BtnSendClick(Sender: TObject);
begin
  if FBusy then
  begin
    // Si ya está ocupado, el clic significa "Cancelar"
    if Assigned(FOnCancel) then
      FOnCancel(Self);
  end
  else
  begin
    // Si no está ocupado, inicia el proceso de envío
    DoSendEvent(nil);
  end;
end;

function TChatInput.BuildFileDialogFilter: string;
var
  ExtList: TStringList;
  I: Integer;
  FilterStr, ExtensionsStr: string;
begin
  Result := '';

  if ValidExtensions = '' then
    Exit;

  ExtList := TStringList.Create;
  try
    ExtList.Delimiter := ',';
    ExtList.StrictDelimiter := True;
    ExtList.DelimitedText := LowerCase(ValidExtensions);

    // Limpiar espacios en blanco
    for I := 0 to ExtList.Count - 1 do
      ExtList[I] := Trim(ExtList[I]);

    // Construir la cadena de extensiones para el filtro
    ExtensionsStr := '';
    for I := 0 to ExtList.Count - 1 do
    begin
      if ExtensionsStr <> '' then
        ExtensionsStr := ExtensionsStr + ';';
      ExtensionsStr := ExtensionsStr + '*.' + ExtList[I];
    end;

    // Crear el filtro completo
    FilterStr := 'Archivos compatibles (' + ExtensionsStr + ')|' + ExtensionsStr;

    // Agregar filtro para todos los archivos
    FilterStr := FilterStr + '|Todos los archivos (*.*)|*.*';

    Result := FilterStr;
  finally
    ExtList.Free;
  end;
end;

procedure TChatInput.ClearSlides;
var
  I: Integer;
  Child: TFMXObject;
begin
  // Liberar la memoria de los TagObject antes de destruir los controles
  for I := FImageLayout.ChildrenCount - 1 downto 0 do
  begin
    Child := FImageLayout.Children[I];
    if (Child is TLayout) and (Child.TagObject is TImageData) then
    begin
      Child.TagObject.Free; // ¡Muy importante!
    end;
  end;

  FImageLayout.DeleteChildren;
  ImagesVisible := False;
  FMemoPrompt.SetFocus;
end;

function TChatInput.CreateBitmapFromImageList(ImageIndex: Integer): TBitMap;
var
  BitmapItem: TBitMap;
begin
  Result := TBitMap.Create;

  if Assigned(FImageList1) and (ImageIndex < FImageList1.Count) then
  begin
    BitmapItem := FImageList1.BitMap(TSizeF.Create(IMAGE_WIDTH, IMAGE_WIDTH), ImageIndex);
    if Assigned(BitmapItem) then
      Result.Assign(BitmapItem)
    else
    begin
      // Si no se puede obtener del ImageList, crear un bitmap vacío
      Result.SetSize(32, 32);
      Result.Clear($FFFFFFFF); // Blanco
    end;
  end
  else
  begin
    // ImageList no disponible o índice inválido
    Result.SetSize(32, 32);
    Result.Clear($FFFFFFFF);
  end;
end;

function TChatInput.LoadImageFromResource(ABitmap: TBitMap; const ResourceName: string): Boolean;
var
  ResourceStream: TResourceStream;
begin
  Result := False;
  try
    ResourceStream := TResourceStream.Create(HInstance, ResourceName, RT_RCDATA);
    try
      if ResourceStream.Size > 0 then
      begin
        ABitmap.LoadFromStream(ResourceStream);
        Result := True;
      end;
    finally
      ResourceStream.Free;
    end;
  except
    // Cualquier excepción (incluyendo EResNotFound) se maneja silenciosamente
    Result := False;
  end;

  // Si no se pudo cargar, crear bitmap en blanco
  if not Result then
  begin
    ABitmap.SetSize(32, 32); // Tamaño por defecto, puedes ajustarlo
    ABitmap.Clear(TAlphaColorRec.Null); // Transparente
  end;
end;

procedure TChatInput.CreateInternalControls;
begin
  // Este método replica la estructura de tu .fmx, pero en código.
  // Es muy importante que 'Self' sea el Parent de todos los controles de primer nivel.

  FChatLayout := TRectangle.Create(Self);
  FChatLayout.Stored := False;

  FChatLayout.Parent := Self;
  FChatLayout.Align := TAlignLayout.Client;
  FChatLayout.Fill.Color := TAlphaColors.White;
  FChatLayout.Stroke.Kind := TBrushKind.None;
  FChatLayout.XRadius := 22;
  FChatLayout.YRadius := 22;
  FChatLayout.OnDragOver := DocsDragOver;
  FChatLayout.OnDragDrop := DocsDragDrop;

  FLayout1 := TLayout.Create(Self);
  FLayout1.Stored := False;
  FLayout1.Parent := FChatLayout;
  FLayout1.Align := TAlignLayout.Bottom;
  FLayout1.Margins.Rect := TRectf.Create(5, 0, 5, 3);
  FLayout1.Height := 24;

  FImageLayout := TFlowLayout.Create(Self);
  FImageLayout.Stored := False;
  FImageLayout.Parent := FChatLayout;
  FImageLayout.Align := TAlignLayout.Top;
  FImageLayout.Margins.Rect := TRectf.Create(8, 4, 8, 0);
  FImageLayout.Height := 50;
  FImageLayout.Visible := False;
  FImageLayout.Justify := TFlowJustify.Left;
  FImageLayout.JustifyLastLine := TFlowJustify.Left;

  FMemoPrompt := TMemo.Create(Self);
  FMemoPrompt.Stored := False;
  FMemoPrompt.Parent := FChatLayout;
  FMemoPrompt.Align := TAlignLayout.Client;
  FMemoPrompt.Margins.Rect := TRectf.Create(5, 3, 5, 3);
  FMemoPrompt.OnChange := MemoPromptChange;
  FMemoPrompt.OnKeyUp := MemoPromptKeyUp;
  FMemoPrompt.OnDragOver := DocsDragOver;
  FMemoPrompt.OnDragDrop := DocsDragDrop;
  FMemoPrompt.StyleLookup := '';

  // Layout inferior (contiene botones, etc.)
  FLayoutSend := TLayout.Create(Self);
  FLayoutSend.Stored := False;
  FLayoutSend.Parent := FLayout1;
  FLayoutSend.Align := TAlignLayout.Right;
  FLayoutSend.Width := 85;

  FBtnMic := TCornerButton.Create(Self);
  FBtnMic.Stored := False;
  FBtnMic.Parent := FLayoutSend;
  FBtnMic.Align := TAlignLayout.MostLeft;
  FBtnMic.Images := FImageListVoice;
  FBtnMic.ImageIndex := 0;
  FBtnMic.SetBounds(0, 0, 24, 24);
  FBtnMic.Margins.Right := 4;
  FBtnMic.Margins.Bottom := 4;
  FBtnMic.XRadius := 8;
  FBtnMic.YRadius := 8;
  FBtnMic.OnClick := BtnMicClick;
  FImageBtnMic := TImage.Create(FBtnMic);
  FImageBtnMic.Stored := False;
  //OJO FImageBtnMic.Parent := FBtnMic;  //Se crea pero no se asigna para pruebas
  FImageBtnMic.Align := TAlignLayout.Client;

  LoadImageFromResource(FImageBtnMic.BitMap, 'MIC_INACTIVO_PNG');
  FImageBtnMic.HitTest := False;

  FBtnSend := TCornerButton.Create(Self);
  FBtnSend.Stored := False;
  FBtnSend.Parent := FLayoutSend;
  FBtnSend.Align := TAlignLayout.Right;
  FBtnSend.SetBounds(0, 0, 24, 24);
  FBtnSend.Margins.Right := 4;
  FBtnSend.Margins.Bottom := 4;
  FBtnSend.XRadius := 8;
  FBtnSend.YRadius := 8;
  FBtnSend.OnClick := BtnSendClick;
  FImageBtnSend := TImage.Create(FBtnSend);
  FImageBtnSend.Stored := False;
  FImageBtnSend.Parent := FBtnSend;
  FImageBtnSend.Align := TAlignLayout.Client;
  FBtnSend.Visible := True;

  // ya no se utiliza aquí LoadImageFromResource(FImageBtnSend.BitMap, 'BTN_SEND_PNG');
  FImageBtnSend.HitTest := False;

  FBtnSound := TCornerButton.Create(Self);
  FBtnSound.Stored := False;
  FBtnSound.Parent := FLayoutSend;
  FBtnSound.Align := TAlignLayout.Left;
  FBtnSound.SetBounds(0, 0, 24, 24);
  FBtnSound.Margins.Right := 4;
  FBtnSound.XRadius := 8;
  FBtnSound.YRadius := 8;
  FBtnSound.Margins.Bottom := 4;
  FBtnSound.Visible := False; // Por defecto
  FImageBtnSound := TImage.Create(FBtnSound);
  FImageBtnSound.Stored := False;
  FImageBtnSound.Parent := FBtnSound;
  FImageBtnSound.Align := TAlignLayout.Client;
  // FImageBtnSound.BitMap.LoadFromResourceName(HInstance, 'IMG_SOUND');
  LoadImageFromResource(FImageBtnSound.BitMap, 'BTN_SOUND_PNG');
  FImageBtnSound.HitTest := False;

  FBtnMenu := TCornerButton.Create(Self);
  FBtnMenu.Stored := False;
  FBtnMenu.Parent := FLayout1;
  FBtnMenu.Align := TAlignLayout.Left;
  FBtnMenu.SetBounds(0, 0, 24, 24);
  FBtnMenu.Margins.Left := 4;
  FBtnMenu.Margins.Bottom := 4;
  FBtnMenu.XRadius := 8;
  FBtnMenu.YRadius := 8;
  FBtnMenu.OnClick := BtnMenuClick;
  FImageBtnMenu := TImage.Create(FBtnMenu);
  FImageBtnMenu.Stored := False;
  FImageBtnMenu.Parent := FBtnMenu;
  FImageBtnMenu.Align := TAlignLayout.Client;
  // FImageBtnMenu.BitMap.LoadFromResourceName(HInstance, 'IMG_PLUS');
  LoadImageFromResource(FImageBtnMenu.BitMap, 'BTN_MENU_PNG');
  FImageBtnMenu.HitTest := False;

  FLayout2 := TLayout.Create(Self);
  FLayout2.Stored := False;
  FLayout2.Parent := FLayout1;
  FLayout2.Align := TAlignLayout.Client;
  FLayout2.Margins.Rect := TRectf.Create(5, 0, 5, 0);

  var
  FLayoutP := TLayout.Create(Self);
  FLayoutP.Stored := False;
  FLayoutP.Parent := FLayout2;
  FLayoutP.Align := TAlignLayout.Contents;
  FLayoutP.Margins.Rect := TRectf.Create(0, 0, 0, 0);

  FProgressBarLevel := TProgressBar.Create(Self);
  FProgressBarLevel.Stored := False;
  FProgressBarLevel.Parent := FLayoutP;
  FProgressBarLevel.Align := TAlignLayout.Bottom;
  FProgressBarLevel.Height := 5;
  FProgressBarLevel.Opacity := 0.8;
  FProgressBarLevel.Margins.Left := 5;

  FLblStatus := TLabel.Create(Self);
  FLblStatus.Stored := False;
  FLblStatus.Parent := FLayout2;
  FLblStatus.Align := TAlignLayout.Client;
  FLblStatus.Text := 'Status:';
  FLblStatus.Margins.Left := 5;
end;

procedure TChatInput.LoadImageResources;
  procedure LoadImg(const AResName: string; AImageList: TImageList);
  var
    BM: TBitMap;
  begin
    try
      BM := TBitMap.Create;
      try
        if LoadImageFromResource(BM, AResName) then
        begin
          try
            AddBitmapToImageList(BM, AImageList, AResName);
          finally
          end;
        end;
      finally
        BM.Free;
      end;
    except
      // Manejar error si el recurso no se encuentra
    end;
  end;

begin

  try

    // Cargar ImageList1
    LoadImg('IMG_PASTE_PNG', FImageList1);
    LoadImg('IMG_UPLOAD_PNG', FImageList1);
    LoadImg('IMG_SCREENSHOT_PNG', FImageList1);
    LoadImg('IMG_CLEARALL_PNG', FImageList1);
    LoadImg('IMG_IMAGE_PNG', FImageList1);
    LoadImg('IMG_PDF_PNG', FImageList1);
    LoadImg('IMG_AUDIO_PNG', FImageList1);
    LoadImg('IMG_VIDEO_PNG', FImageList1);
    LoadImg('IMG_DOC_PNG', FImageList1);
    LoadImg('IMG_UNKNOWN_PNG', FImageList1);
    // LoadImg('IMG_UNKNOWN_PNG', FImageList1);

    // Cargar ImageListVoice
    LoadImg('MIC_INACTIVO_PNG', FImageListVoice);
    LoadImg('MIC_PREPARING_PNG', FImageListVoice);
    LoadImg('MIC_LISTENING_PNG', FImageListVoice);
    LoadImg('MIC_USERTALKING_PNG', FImageListVoice);
    LoadImg('MIC_IATALKING_PNG', FImageListVoice);

  finally
  end;
end;

procedure TChatInput.Loaded;
begin
  inherited; // ¡Siempre llama al inherited primero!

  // En este punto, el componente está completamente cargado desde el FMX.
  // Es el momento perfecto y seguro para capturar las dimensiones iniciales.

  // La bandera FInitialHeightsCaptured sigue siendo útil por si alguna lógica
  // futura pudiera volver a llamar a esto, aunque con Loaded no es estrictamente necesario.
  if not FInitialHeightsCaptured then
  begin
    // Comprobamos que el componente no esté oculto o con tamaño cero
    if (Self.Height > 0) and Assigned(FMemoPrompt) then
    begin
      FInitialMemoHeight := FMemoPrompt.Height;
      FInitialFrameHeight := Self.Height;
      FInitialHeightsCaptured := True;
    end;
  end;

  // --- APLICAR LA FUENTE INICIAL ---
  // Aplica la configuración de FFont (ya sea la por defecto o la del diseñador)
  // al TMemo interno.
  FontChanged(Self); // <-- NUEVO
end;

procedure TChatInput.LoadFromFile;
var
  BitMap: TBitMap;
  St: TMemoryStream;
  FileName, Ext: string;
  ContentType: TContentType;
  ImageIndex: Integer;
  OpenDialogImage: TOpenDialog;
begin
  OpenDialogImage := TOpenDialog.Create(Self);
  Try
    // Configurar el filtro del diálogo basado en las extensiones válidas
    if FValidExtensions <> '' then
      OpenDialogImage.Filter := BuildFileDialogFilter;

    if OpenDialogImage.Execute then
    begin
      FileName := OpenDialogImage.FileName;
      Ext := System.IOUtils.TPath.GetExtension(FileName).ToLower;

      // Validar que la extensión esté en la lista de extensiones válidas
      if not IsValidFileExtension(Ext) then
      begin
        ShowMessage('Tipo de archivo no compatible: ' + Ext);
        Exit;
      end;

      if not TFile.Exists(FileName) then
      begin
        ShowMessage('El archivo seleccionado no existe.');
        Exit;
      end;

      // Obtener el tipo de contenido
      ContentType := GetContentTypeFromValidExtensions(Ext);
      St := TMemoryStream.Create;
      BitMap := nil;

      try
        if ContentType = ctImage then
        begin
          // Para imágenes, cargar la imagen real
          BitMap := TBitMap.Create;
          try
            BitMap.LoadFromFile(FileName);
            BitMap.SaveToStream(St);
            St.Position := 0;
          except
            on E: Exception do
            begin
              BitMap.Free;
              St.Free;
              ShowMessage('Error al cargar la imagen: ' + E.Message);
              Exit;
            end;
          end;
        end
        else
        begin
          // Para otros tipos, cargar el archivo como stream y usar icono del ImageList
          try
            St.LoadFromFile(FileName);
            St.Position := 0;
            ImageIndex := GetImageIndexFromContentType(ContentType);
            BitMap := CreateBitmapFromImageList(ImageIndex);
          except
            on E: Exception do
            begin
              if Assigned(BitMap) then
                BitMap.Free;
              St.Free;
              ShowMessage('Error al cargar el archivo: ' + E.Message);
              Exit;
            end;
          end;
        end;

        // Agregar el elemento a la lista
        AddImageToSlide(ExtractFileName(FileName), BitMap, St);

      except
        on E: Exception do
        begin
          // Limpieza de seguridad en caso de error
          if Assigned(BitMap) then
            BitMap.Free;
          if Assigned(St) then
            St.Free;
          ShowMessage('Error al procesar el archivo: ' + E.Message);
        end;
      end;
    end;
  Finally
    OpenDialogImage.Free;
  End;
end;

procedure TChatInput.MemoPromptChange(Sender: TObject);
begin
  UpdateChatLayoutHeight;
end;

procedure TChatInput.MemoPromptKeyUp(Sender: TObject; var Key: Word; var KeyChar: WideChar; Shift: TShiftState);
begin
  If (ssCtrl in Shift) and (Key = vkReturn) then
  Begin
    DoSendEvent(Nil);
    Key := 0;
  End;
end;

procedure TChatInput.MenuItem2Click(Sender: TObject);
begin
  ShowMessage('Hola');
end;

procedure TChatInput.OnSlideItemDelete(Sender: TObject);
begin
  If Assigned(Sender) and (Assigned(TFMXObject(Sender).TagObject)) then
  Begin
    DeleteSlideItem(TFMXObject(TFMXObject(Sender).TagObject));
  End;
end;

procedure TChatInput.PasteFromClipBoard;
var
  ClipboardService: IFMXClipboardService;
  BitMap: TBitMap;
  Sur: TBitMapSurface;
  St: TMemoryStream;
  ContentType: TContentType;
  ImageIndex: Integer;
  ClipboardText: string;
  ClipboardData: TBytes;
  FileName: string;
begin
  if not TPlatformServices.Current.SupportsPlatformService(IFMXClipboardService, IInterface(ClipboardService)) then
  begin
    ShowMessage('El servicio de portapapeles no está disponible.');
    FMemoPrompt.SetFocus;
    Exit;
  end;

  St := TMemoryStream.Create;
  BitMap := nil;
  ContentType := ctUnknown;

  try
    // Verificar si hay una imagen en el portapapeles
    if (ClipboardService.GetClipboard.Kind = tkClass) and (ClipboardService.GetClipboard.AsObject is TBitMapSurface) then
    begin
      // Es una imagen
      Sur := TBitMapSurface(ClipboardService.GetClipboard.AsObject);
      BitMap := TBitMap.Create;
      BitMap.SetSize(Sur.Width, Sur.Height);
      BitMap.Assign(Sur);
      BitMap.SaveToStream(St);
      ContentType := ctImage;
      FileName := 'imagen.png';
    end
    // Verificar si hay texto en el portapapeles
    else if ClipboardService.GetClipboard.Kind = tkUString then
    begin
      ClipboardText := ClipboardService.GetClipboard.AsString;
      ContentType := GetContentTypeFromText(ClipboardText);

      // Convertir texto a stream
      ClipboardData := TEncoding.UTF8.GetBytes(ClipboardText);
      St.WriteBuffer(ClipboardData[0], Length(ClipboardData));
      St.Position := 0;

      case ContentType of
        ctText:
          FileName := 'texto.txt';
        ctPDF:
          FileName := 'documento.pdf';
        ctImage:
          FileName := 'imagen.jpg';
        ctAudio:
          FileName := 'audio.mp3';
        ctVideo:
          FileName := 'video.mp4';
        ctDocument:
          FileName := 'documento.doc';
      else
        FileName := 'archivo.dat';
      end;
    end
    // Verificar si hay datos binarios en el portapapeles
    else if ClipboardService.GetClipboard.Kind = tkRecord then
    begin
      // Intentar obtener datos como bytes (esto puede variar según la plataforma)
      try
        ClipboardText := ClipboardService.GetClipboard.AsString;
        ClipboardData := TEncoding.Default.GetBytes(ClipboardText);

        if Length(ClipboardData) > 0 then
        begin
          ContentType := GetContentTypeFromData(ClipboardData);
          St.WriteBuffer(ClipboardData[0], Length(ClipboardData));
          St.Position := 0;

          case ContentType of
            ctPDF:
              FileName := 'documento.pdf';
            ctImage:
              FileName := 'imagen.jpg';
            ctAudio:
              FileName := 'audio.mp3';
            ctVideo:
              FileName := 'video.mp4';
            ctDocument:
              FileName := 'documento.doc';
          else
            FileName := 'archivo.dat';
          end;
        end;
      except
        ContentType := ctUnknown;
        FileName := 'archivo.dat';
      end;
    end
    else
    begin
      Raise Exception.Create('El portapapeles no contiene contenido compatible.');
      FMemoPrompt.SetFocus;
      Exit;
    end;

    // Si no es una imagen, crear bitmap desde ImageList
    if (ContentType <> ctImage) or (BitMap = nil) then
    begin
      ImageIndex := GetImageIndexFromContentType(ContentType);
      BitMap := CreateBitmapFromImageList(ImageIndex);
    end;

    // Reiniciar posición del stream
    St.Position := 0;

    // Agregar el elemento a la lista
    AddImageToSlide(FileName, BitMap, St);

  finally
    if Assigned(BitMap) then
      BitMap.Free;
    St.Free;
    FMemoPrompt.SetFocus;
  end;
end;

function TChatInput.ScaleRectangle(MaxSize, X, Y: Double; var ScaledX, ScaledY: Double): Boolean;
var
  AspectRatio: Double;
begin

  // Inicialmente, los resultados son iguales a los valores originales
  ScaledX := X;
  ScaledY := Y;

  // Si ambos lados son menores o iguales a 500, no se necesita escalar
  if (X <= MaxSize) and (Y <= MaxSize) then
  begin
    ScaledX := X;
    ScaledY := Y;
    Result := False; // No se ha escalado
    Exit;
  end;

  // Calcular la relación de aspecto
  AspectRatio := X / Y;

  if X > Y then
  begin
    // Escalar por el ancho
    ScaledX := MaxSize;
    ScaledY := MaxSize / AspectRatio;
  end
  else
  begin
    // Escalar por el alto
    ScaledY := MaxSize;
    ScaledX := MaxSize * AspectRatio;
  end;

  Result := True; // Se ha escalado
end;

procedure TChatInput.ScreenCapture;
Var
  BM: TBitMap;
  St: TMemoryStream;
  Rec: TRect;
begin
  If TScreenCapture.SelectArea(Rec) then
  Begin
    BM := TScreenCapture.CaptureArea(Rec);
    // Bm.SaveToFile('c:\temp\caputra.jpg');
    St := TMemoryStream.Create;
    BM.SaveToStream(St);
    AddImageToSlide('imagen.jpg', BM, St);
    FMemoPrompt.SetFocus;
  End;
end;

procedure TChatInput.SetBusy(const Value: Boolean);
begin
  if FBusy <> Value then
  begin
    FBusy := Value;

    if csDesigning in ComponentState then
      Exit;

    TThread.Queue(nil,
      procedure
      begin
        // Actualizar la UI basado en el nuevo estado de 'Busy'
        if FBusy then
        begin
          // --- ESTADO OCUPADO ---
          FImageBtnSend.BitMap.Assign(FCancelBitmap); // Cambia el icono a "Cancelar"
          FMemoPrompt.ReadOnly := True;
          FBtnMenu.Enabled := False; // Buena idea deshabilitar el menú también
        end
        else
        begin
          // --- ESTADO NORMAL ---
          FImageBtnSend.BitMap.Assign(FSendBitmap); // Vuelve al icono de "Enviar"
          FMemoPrompt.ReadOnly := False;
          FBtnMenu.Enabled := True;
          FMemoPrompt.SetFocus; // Devuelve el foco al memo
        end;
      end);
  end;
end;

procedure TChatInput.SetFont(const Value: TFont);
begin
  FFont.Assign(Value);
end;

procedure TChatInput.SetImagesVisible(const Value: Boolean);
begin

  if not Assigned(FImageLayout) or not Assigned(FChatLayout) then
    Exit;

  If FImagesVisible <> Value then
  Begin
    FImagesVisible := Value;

    FChatLayout.BeginUpdate;
    Try
      FImageLayout.Visible := FImagesVisible;

      If FImageLayout.Visible then
        FChatLayout.Height := FChatLayout.Height + IMAGE_WIDTH
      Else
        FChatLayout.Height := FChatLayout.Height - IMAGE_WIDTH;

      UpdateChatLayoutHeight;
    Finally
      FChatLayout.EndUpdate;
    End;
  End;

end;

procedure TChatInput.SetMicImageStatus(IdImage: Integer);
begin
  TThread.Queue(nil,
    procedure
    begin
      FBtnMic.ImageIndex := IdImage;
    end);
end;

procedure TChatInput.SetMicVisible(const Value: Boolean);
begin
  if not Assigned(FBtnMic) then
    Exit;

  FMicVisible := Value;
  FBtnMic.Visible := FMicVisible;
  RecalcLayoutSend;
end;

procedure TChatInput.SetOnCancel(const Value: TNotifyEvent);
begin
  FOnCancel := Value;
end;

procedure TChatInput.SetOnSendEvent(const Value: TChatSendEvent);
begin
  FOnSendEvent := Value;
end;

procedure TChatInput.SetOnTranscriptText(const Value: TChatTranscriptEvent);
begin
  FOnTranscriptText := Value;
end;

procedure TChatInput.SetUseSoundMonitor(const Value: Boolean);
begin
  If FUseSoundMonitor <> Value then
  Begin
    ActiveSoundMonitor(FUseSoundMonitor);
    FUseSoundMonitor := Value;
  End;
end;

procedure TChatInput.SetSoundVisible(const Value: Boolean);
begin
  FSoundVisible := Value;
  FBtnSound.Visible := FSoundVisible;
  RecalcLayoutSend;
end;

procedure TChatInput.SetValidExtensions(const Value: String);
begin
  FValidExtensions := Value;
end;

procedure TChatInput.SetVoiceMonitor(const Value: TAIVoiceMonitor);
begin
  If Assigned(Value) then
  Begin
    FVoiceMonitor := Value;
    FVoiceMonitor.OnCalibrated := AIVoiceMonitorCalibrated;
    FVoiceMonitor.OnChangeState := AIVoiceMonitorChangeState;
    FVoiceMonitor.OnError := AIVoiceMonitorError;
    FVoiceMonitor.OnSpeechEnd := AIVoiceMonitorSpeechEnd;
    FVoiceMonitor.OnTranscriptionFragment := AIVoiceMonitorTranscriptionFragment;
    FVoiceMonitor.OnUpdate := AIVoiceMonitorUpdate;
    FVoiceMonitor.OnWakeWordCheck := AIVoiceMonitorWakeWordCheck;
  End
  Else
  Begin
    FVoiceMonitor := Nil;
  End;
end;

procedure TChatInput.StartMonitoring;
begin

  If Not Assigned(FVoiceMonitor) then
    Exit;

  AddStatus('Preparando el ambiente, por favor espere');

  FCurrentSoundLevel := 0;
  FMaxLevelSeen := 100; // Resetear el máximo para que la barra se ajuste
  FProgressBarLevel.Max := FMaxLevelSeen;

  FAnimationTimer.Enabled := True;

  FVoiceMonitor.Active := True;

  FBtnMic.ImageIndex := Integer(TImageStatus.isPreparing);

end;

procedure TChatInput.StopMonitoring;
begin
  If Not Assigned(FVoiceMonitor) then
    Exit;

  FVoiceMonitor.Active := False;
  FAnimationTimer.Enabled := False;

  // Habilitar controles
  FProgressBarLevel.Value := 0;
  AddStatus('Monitor Inactivo');
  FBtnMic.ImageIndex := Integer(TImageStatus.isInactivo);
end;

procedure TChatInput.Timer1Timer(Sender: TObject);
begin
  UpdateChatLayoutHeight;
  FMnuClear.Enabled := FImageLayout.ChildrenCount > 0;

  If FMemoPrompt.StyleLookup <> 'memostyle' then
  Begin

    if csDesigning in ComponentState then
      Exit;

    // Elimina el fondo blanco del memo y el borde
    FMemoPrompt.StyleLookup := 'memostyle';
    FMemoPrompt.ApplyStyleLookup;

    Var
    StyleObj := FMemoPrompt.FindStyleResource('background');
    if (StyleObj <> nil) and (StyleObj is TActiveStyleObject) then
    begin
      TActiveStyleObject(StyleObj).Opacity := 0;
    end;
  End;
end;

procedure TChatInput.UpdateChatLayoutHeight;
var
  RequiredMemoHeight, NewMemoHeight, NewFrameHeight: Single;
  Padding: Single; // <-- NUEVO: Variable para el colchón
begin
  // Asegurarnos de que las alturas iniciales hayan sido capturadas
  if not FInitialHeightsCaptured then
    Exit;

  // --- Paso 1: Calcular la altura necesaria para el Memo ---

  // Definimos un pequeño colchón de píxeles para evitar la barra de scroll.
  // Un valor entre 2 y 5 suele ser suficiente.
  Padding := 4; // <-- NUEVO

  // Calculamos la altura del contenido y le sumamos los márgenes Y el nuevo padding.
  RequiredMemoHeight := FMemoPrompt.ContentBounds.Height + FMemoPrompt.Margins.Top + FMemoPrompt.Margins.Bottom + Padding; // <-- CAMBIO CLAVE

  // El resto de la lógica permanece igual
  RequiredMemoHeight := Max(FInitialMemoHeight, RequiredMemoHeight);
  NewMemoHeight := Min(MAX_MEMO_HEIGHT, RequiredMemoHeight);

  // --- Paso 2: Calcular la altura total que necesita el FRAME ---
  NewFrameHeight := 0;

  // Sumar la altura del layout de imágenes si es visible
  if FImageLayout.Visible then
  begin
    NewFrameHeight := NewFrameHeight + FImageLayout.Height + FImageLayout.Margins.Top + FImageLayout.Margins.Bottom;
  end;

  // Sumar la altura (ya calculada) del Memo
  NewFrameHeight := NewFrameHeight + NewMemoHeight;

  // Sumar la altura del layout inferior (botones, etc.)
  NewFrameHeight := NewFrameHeight + FLayout1.Height + FLayout1.Margins.Top + FLayout1.Margins.Bottom;

  // Añadir paddings si los tuviera el ChatLayout
  NewFrameHeight := NewFrameHeight + FChatLayout.Padding.Top + FChatLayout.Padding.Bottom;

  // --- PASO 3: Forzar la altura mínima ---
  NewFrameHeight := Max(MIN_FRAME_HEIGHT, NewFrameHeight);

  // --- Paso 4: Aplicar los cambios si son necesarios ---
  if (Abs(NewMemoHeight - FMemoPrompt.Height) > 0.1) or (Abs(NewFrameHeight - Self.Height) > 0.1) then
  begin
    FMemoPrompt.Height := NewMemoHeight;
    Self.Height := NewFrameHeight;
  end;

  FTimer.Enabled := True;
end;

procedure TChatInput.DeleteSlideItem(ItemToDelete: TFMXObject);
begin
  if (ItemToDelete.TagObject is TImageData) then
  begin
    TObject(ItemToDelete.TagObject).Free;
    ItemToDelete.TagObject := nil;
  end;

  ItemToDelete.Free;

  ImagesVisible := FImageLayout.ChildrenCount > 0;
end;

destructor TChatInput.Destroy;
begin
  FFont.Free;
  FSendBitmap.Free;
  FCancelBitmap.Free;
  inherited;
end;

procedure TChatInput.DocsDragDrop(Sender: TObject; const Data: TDragObject; const Point: TPointF);
var
  I: Integer;
  FileName, Ext, CleanPath: string;
  BitMap: TBitMap;
  Uri: TURI;
  St: TMemoryStream;
  ContentType: TContentType;
  ImageIndex: Integer;
  ByteData: TBytes; // Variable para almacenar los bytes del stream
begin
  BitMap := Nil;
  try
    // --- Caso 1: Se arrastran archivos desde el explorador ---
    if Length(Data.Files) > 0 then
    begin
      for I := 0 to High(Data.Files) do
      begin
        FileName := Data.Files[I];
        // Usamos TPath.GetExtension para obtener la extensión de forma segura
        Ext := System.IOUtils.TPath.GetExtension(FileName).ToLower;

        // Validar con la lista de extensiones configurada
        if IsValidFileExtension(Ext) then
        begin
          if TFile.Exists(FileName) then
          begin
            // Obtener el tipo de contenido
            ContentType := GetContentTypeFromValidExtensions(Ext);
            St := TMemoryStream.Create;
            BitMap := nil;

            try
              if ContentType = ctImage then
              begin
                // Para imágenes, cargar la imagen real
                BitMap := TBitMap.Create;
                BitMap.LoadFromFile(FileName);
                BitMap.SaveToStream(St);
                St.Position := 0;
              end
              else
              begin
                // Para otros tipos, cargar el archivo como stream y usar icono del ImageList
                St.LoadFromFile(FileName);
                St.Position := 0;
                ImageIndex := GetImageIndexFromContentType(ContentType);
                BitMap := CreateBitmapFromImageList(ImageIndex);
              end;

              AddImageToSlide(FileName, BitMap, St);
            except
              // Si algo falla, liberamos los recursos
              if Assigned(BitMap) then
                BitMap.Free;
              St.Free;
              raise; // Re-lanzamos la excepción
            end;
          end;
        end;
      end;
    end
    // --- Caso 2: Se arrastra una URL (texto) desde el navegador ---
    else
    begin
      FileName := Data.Data.AsString;
      if FileName.StartsWith('http://', True) or FileName.StartsWith('https://', True) then
      begin
        // Usamos TURI para analizar la URL y TPath para obtener la extensión de forma robusta.
        Uri := TURI.Create(FileName);
        try
          CleanPath := Uri.Path;
          Ext := System.IOUtils.TPath.GetExtension(CleanPath).ToLower;
        finally
          // Uri se libera automáticamente (es un record)
        end;

        // Validar con la lista de extensiones configurada
        if IsValidFileExtension(Ext) then
        begin
          ContentType := GetContentTypeFromValidExtensions(Ext);
          St := nil;
          BitMap := nil;

          try
            if ContentType = ctImage then
            begin
              // Para imágenes, descargar y cargar la imagen
              St := DownLoadFromUrl(FileName);
              if (St = nil) or (St.Size = 0) then
                raise Exception.Create('La descarga resultó en un stream vacío.');
              St.Position := 0;
              BitMap := TBitMap.Create;
              BitMap.LoadFromStream(St);
            end
            else
            begin
              // Para otros tipos, descargar como stream y usar icono
              St := DownLoadFromUrl(FileName);
              if (St = nil) or (St.Size = 0) then
                raise Exception.Create('La descarga resultó en un stream vacío.');
              St.Position := 0;
              ImageIndex := GetImageIndexFromContentType(ContentType);
              BitMap := CreateBitmapFromImageList(ImageIndex);
            end;

            AddImageToSlide(FileName, BitMap, St);
          except
            // Si algo falla, liberamos los recursos
            if Assigned(BitMap) then
              BitMap.Free;
            if Assigned(St) then
              St.Free;
            raise; // Re-lanzamos la excepción
          end;
        end
        else
        begin
          // Si no tiene extensión reconocible, intentar detectar por contenido
          St := DownLoadFromUrl(FileName);
          if (St <> nil) and (St.Size > 0) then
          begin
            try
              St.Position := 0;
              // Intentar detectar tipo por contenido del stream
              SetLength(ByteData, St.Size);
              St.ReadBuffer(ByteData[0], St.Size);
              ContentType := GetContentTypeFromData(ByteData);

              if ContentType <> ctUnknown then
              begin
                St.Position := 0;
                if ContentType = ctImage then
                begin
                  BitMap := TBitMap.Create;
                  BitMap.LoadFromStream(St);
                end
                else
                begin
                  ImageIndex := GetImageIndexFromContentType(ContentType);
                  BitMap := CreateBitmapFromImageList(ImageIndex);
                end;

                AddImageToSlide(FileName, BitMap, St);
              end
              else
              begin
                St.Free;
                ShowMessage('Tipo de archivo no compatible detectado en la URL.');
              end;
            except
              if Assigned(BitMap) then
                BitMap.Free;
              St.Free;
              raise;
            end;
          end;
        end;
      end;
    end;
  except
    on E: Exception do
    begin
      // Mensaje de error genérico para el usuario
      ShowMessage('Error al procesar el archivo: ' + E.Message);
    end;
  end;
end;

function TChatInput.DownLoadFromUrl(sUrl: String): TMemoryStream;
Var
  Client: THTTPClient;
  Res: IHTTPResponse;
  Response: TMemoryStream;
begin

  Result := TMemoryStream.Create;
  Client := THTTPClient.Create;
  Response := TStringStream.Create('', TEncoding.UTF8);

  Try
    Client.ContentType := 'application/octet-stream';

    Res := Client.Get(sUrl, Response);

    if Res.StatusCode = 200 then
    Begin
      Response.Position := 0;
      Result.LoadFromStream(Response);
    End
    else
    begin
      Raise Exception.CreateFmt('Error Received: %d, %s', [Res.StatusCode, Res.ContentAsString]);
    end;
  Finally
    Client.Free;
    Response.Free;
  End;
end;

procedure TChatInput.FontChanged(Sender: TObject);
begin
  if Assigned(FMemoPrompt) then
  begin
    // Usamos TextSettings.Font para componentes FMX
    FMemoPrompt.TextSettings.Font.Assign(FFont);
    // Forzamos una actualización de la altura en caso de que el tamaño de la fuente cambie el contenido.
    UpdateChatLayoutHeight;
  end;
end;

procedure TChatInput.RecalcLayoutSend;
Var
  W: Integer;
begin
  W := 0;
  If FBtnMic.Visible then
    W := W + 24 + 4;
  If FBtnSend.Visible then
    W := W + 24 + 4;
  If FBtnSound.Visible then
    W := W + 24 + 4;

  FLayoutSend.Width := W;

end;

procedure TChatInput.Resize;
begin
  // Heredamos el comportamiento por defecto
  inherited;

end;

function TChatInput.GetContentTypeFromData(const Data: TBytes): TContentType;
begin
  Result := ctUnknown;

  if Length(Data) < 4 then
    Exit;

  // Detectar tipo por signatura de bytes
  // PDF
  if (Data[0] = $25) and (Data[1] = $50) and (Data[2] = $44) and (Data[3] = $46) then // %PDF
    Result := ctPDF
    // PNG
  else if (Data[0] = $89) and (Data[1] = $50) and (Data[2] = $4E) and (Data[3] = $47) then
    Result := ctImage
    // JPEG
  else if (Data[0] = $FF) and (Data[1] = $D8) and (Data[2] = $FF) then
    Result := ctImage
    // GIF
  else if (Data[0] = $47) and (Data[1] = $49) and (Data[2] = $46) then
    Result := ctImage
    // BMP
  else if (Data[0] = $42) and (Data[1] = $4D) then
    Result := ctImage
    // MP3
  else if (Data[0] = $49) and (Data[1] = $44) and (Data[2] = $33) then // ID3
    Result := ctAudio
    // WAV
  else if (Data[0] = $52) and (Data[1] = $49) and (Data[2] = $46) and (Data[3] = $46) then // RIFF
    Result := ctAudio
    // MP4/MOV
  else if Length(Data) > 8 then
  begin
    if (Data[4] = $66) and (Data[5] = $74) and (Data[6] = $79) and (Data[7] = $70) then // ftyp
      Result := ctVideo;
  end
  // AVI
  else if (Data[0] = $52) and (Data[1] = $49) and (Data[2] = $46) and (Data[3] = $46) and (Length(Data) > 8) and (Data[8] = $41) and (Data[9] = $56) and (Data[10] = $49) then // RIFF...AVI
    Result := ctVideo
    // ZIP/DOCX/XLSX/PPTX
  else if (Data[0] = $50) and (Data[1] = $4B) and (Data[2] = $03) and (Data[3] = $04) then
    Result := ctDocument;
end;

function TChatInput.GetContentTypeFromText(const Text: string): TContentType;
var
  LowerText: string;
begin
  Result := ctText;
  LowerText := LowerCase(Text);

  // Detectar URLs o referencias a archivos
  if (Pos('http://', LowerText) = 1) or (Pos('https://', LowerText) = 1) then
  begin
    if (Pos('.pdf', LowerText) > 0) then
      Result := ctPDF
    else if (Pos('.jpg', LowerText) > 0) or (Pos('.png', LowerText) > 0) or (Pos('.gif', LowerText) > 0) or (Pos('.bmp', LowerText) > 0) then
      Result := ctImage
    else if (Pos('.mp3', LowerText) > 0) or (Pos('.wav', LowerText) > 0) or (Pos('.m4a', LowerText) > 0) then
      Result := ctAudio
    else if (Pos('.mp4', LowerText) > 0) or (Pos('.avi', LowerText) > 0) or (Pos('.mov', LowerText) > 0) then
      Result := ctVideo
    else if (Pos('.doc', LowerText) > 0) or (Pos('.xls', LowerText) > 0) or (Pos('.ppt', LowerText) > 0) then
      Result := ctDocument;
  end;
end;

function TChatInput.GetImageIndexFromContentType(ContentType: TContentType): Integer;
begin
  case ContentType of
    ctImage:
      Result := IMG_INDEX_IMAGE;
    ctPDF:
      Result := IMG_INDEX_PDF;
    ctAudio:
      Result := IMG_INDEX_AUDIO;
    ctVideo:
      Result := IMG_INDEX_VIDEO;
    ctDocument:
      Result := IMG_INDEX_DOCUMENT;
    ctText:
      Result := IMG_INDEX_TEXT;
  else
    Result := IMG_INDEX_UNKNOWN;
  end;
end;

procedure TChatInput.InitPopupMenu;
Var
  Item: TMenuItem;
begin

  If Assigned(FMenu) then
    Exit;

  if not(csLoading in ComponentState) then
  begin
    FMenu := TPopupMenu.Create(Self);
    FMenu.Images := FImageList1;

    // Crear items del menú
    FMnuPaste := TMenuItem.Create(FMenu);
    FMnuPaste.Name := 'MnuPaste';
    FMnuPaste.Text := 'Paste';
    FMnuPaste.OnClick := ac_pasteExecute;
    FMnuPaste.ImageIndex := 0; // Corresponde a IMG_PASTE
    FMenu.AddObject(FMnuPaste);

    Item := TMenuItem.Create(FMenu);
    Item.Text := 'Upload File';
    Item.OnClick := ac_UploadFileExecute;
    Item.ImageIndex := 1; // Corresponde a IMG_UPLOAD
    FMenu.AddObject(Item);

    Item := TMenuItem.Create(FMenu);
    Item.Text := 'Screenshot';
    Item.OnClick := ac_ScreenShotExecute;
    Item.ImageIndex := 2; // Corresponde a IMG_SCREENSHOT
    FMenu.AddObject(Item);

    FMnuClear := TMenuItem.Create(FMenu);
    FMnuClear.Text := 'Clear All';
    FMnuClear.OnClick := ac_ClearExecute;
    FMnuClear.ImageIndex := 3; // Corresponde a IMG_CLEAR
    FMenu.AddObject(FMnuClear);

    FBtnMenu.PopupMenu := FMenu;
  end;

end;

function TChatInput.IsValidFileExtension(const Extension: string): Boolean;
var
  ExtList: TStringList;
  CleanExt: string;
  I: Integer;
begin
  Result := False;

  if (Extension = '') or (ValidExtensions = '') then
    Exit;

  // Limpiar la extensión (quitar el punto si lo tiene)
  CleanExt := Extension;
  if (Length(CleanExt) > 0) and (CleanExt[1] = '.') then
    CleanExt := Copy(CleanExt, 2, Length(CleanExt));

  CleanExt := LowerCase(CleanExt);

  ExtList := TStringList.Create;
  try
    ExtList.Delimiter := ',';
    ExtList.StrictDelimiter := True;
    ExtList.DelimitedText := LowerCase(ValidExtensions);

    // Limpiar espacios en blanco de cada elemento
    for I := 0 to ExtList.Count - 1 do
      ExtList[I] := Trim(ExtList[I]);

    Result := ExtList.IndexOf(CleanExt) >= 0;
  finally
    ExtList.Free;
  end;
end;

procedure TChatInput.DocsDragOver(Sender: TObject; const Data: TDragObject; const Point: TPointF; var Operation: TDragOperation);
var
  Ext: String;
  S: String;
  UrlExt: String;
  I: Integer;
begin
  Operation := TDragOperation.None;

  // Si son archivos
  if (Length(Data.Files) > 0) then
  begin
    Ext := ExtractFileExt(LowerCase(Data.Files[0]));
    if IsValidFileExtension(Ext) then
      Operation := TDragOperation.Copy;
  end
  else
  begin
    S := Data.Data.AsString;

    // Verificar si es una URL
    if (Copy(S, 1, 7) = 'http://') or (Copy(S, 1, 8) = 'https://') then
    begin
      // Buscar la extensión en la URL de manera más robusta
      I := LastDelimiter('/', S);
      if I > 0 then
      begin
        UrlExt := ExtractFileExt(LowerCase(Copy(S, I + 1, Length(S))));
        // También verificar parámetros de consulta
        I := Pos('?', UrlExt);
        if I > 0 then
          UrlExt := Copy(UrlExt, 1, I - 1);

        if IsValidFileExtension(UrlExt) then
          Operation := TDragOperation.Move;
      end
      else
      begin
        // Si no hay extensión visible, permitir el drop para URLs genéricas
        // Se detectará el tipo en el evento Drop
        Operation := TDragOperation.Move;
      end;
    end
    else
    begin
      // Verificar si el texto contiene una ruta de archivo válida
      if Pos('\', S) > 0 then // Ruta Windows
      begin
        Ext := ExtractFileExt(LowerCase(S));
        if IsValidFileExtension(Ext) then
          Operation := TDragOperation.Move;
      end;
    end;
  end;
end;

{ procedure TChatInput.DoSendEvent(aAudioFile: TMemoryStream);
  Var
  APrompt: String;
  MediaFiles: TAiMediaFiles;
  MF: TAiMediaFile;
  Data: TImageData;
  I: Integer;
  St: TMemoryStream;
  begin

  If Busy = False then
  Begin
  Busy := True;

  MediaFiles := TAiMediaFiles.Create; // Siempre se crea
  Try
  If Assigned(FOnSendEvent) then
  Begin
  // Aquí crea la lista de MediaFiles
  If FImageLayout.ChildrenCount > 0 then
  Begin
  For I := 0 to FImageLayout.ChildrenCount - 1 do
  Begin
  If FImageLayout.Children[I] is TLayout then
  Begin
  Data := TImageData(TLayout(FImageLayout.Children[I]).TagObject);

  St := TMemoryStream.Create;
  Try
  Data.Stream.SaveToStream(St);
  MF := TAiMediaFile.Create;
  MF.LoadFromStream(Data.FileName, St);
  MediaFiles.Add(MF);
  Finally
  St.Free;
  End;
  End;
  End;
  End;

  APrompt := Trim(FMemoPrompt.Lines.Text);
  FOnSendEvent(Self, APrompt, MediaFiles, aAudioFile);
  FMemoPrompt.Lines.Clear;
  ClearSlides;
  UpdateChatLayoutHeight;
  End
  Else
  Begin
  Busy := False;

  End;
  Finally
  MediaFiles.Free;
  End;
  End;
  end;
}

procedure TChatInput.DoSendEvent(aAudioFile: TMemoryStream);
Var
  APrompt: String;
  MediaFiles: TAiMediaFiles;
  MF: TAiMediaFile;
  Data: TImageData;
  I: Integer;
  St: TMemoryStream;
begin
  // BtnSendClick ya ha verificado que Busy es False.

  // 1. Poner la UI en estado "Ocupado" INMEDIATAMENTE.
  Self.Busy := True; // Esto llama a SetBusy y actualiza la UI al instante.

  // Si no hay un manejador para el evento, no podemos continuar.
  // Volvemos al estado normal.
  if not Assigned(FOnSendEvent) then
  begin
    Self.Busy := False;
    Exit;
  end;

  MediaFiles := TAiMediaFiles.Create;
  try
    // 2. Preparar la lista de MediaFiles de forma síncrona.
    // Esta parte puede causar un breve bloqueo si los archivos son grandes,
    // pero es la responsabilidad que el componente asume según tu diseño.
    if FImageLayout.ChildrenCount > 0 then
    begin
      for I := 0 to FImageLayout.ChildrenCount - 1 do
      begin
        if FImageLayout.Children[I] is TLayout then
        begin
          Data := TImageData(TLayout(FImageLayout.Children[I]).TagObject);
          St := TMemoryStream.Create;
          try
            Data.Stream.Position := 0;
            Data.Stream.SaveToStream(St);
            St.Position := 0; // Rebobinar el stream para su lectura

            MF := TAiMediaFile.Create;
            // OJO: Asumimos que LoadFromStream hace una copia de los datos del stream
            // y no toma posesión del stream `St`.
            MF.LoadFromStream(Data.FileName, St);
            MediaFiles.Add(MF);
          finally
            St.Free; // `St` es temporal y se libera aquí.
          end;
        end;
      end;
    end;

    // 3. Capturar el prompt y disparar el evento.
    // El control se pasa al código del formulario.
    APrompt := Trim(FMemoPrompt.Lines.Text);
    FOnSendEvent(Self, APrompt, MediaFiles, aAudioFile);

    // 4. Limpiar la UI para el siguiente mensaje.
    // Esto se ejecuta DESPUÉS de que el manejador OnSendEvent del usuario retorne.
    FMemoPrompt.Lines.Clear;
    ClearSlides;
    UpdateChatLayoutHeight;

    // NOTA: NO hacemos "Busy := False" aquí.
    // Esa es la responsabilidad del código del formulario.

  finally
    // 5. Liberar la lista de MediaFiles. El consumidor ya los ha procesado.
    MediaFiles.Free;
  end;
end;

procedure TChatInput.DoTranscriptText(aFragmentStream: TMemoryStream; out aTransriptText: String);
begin
  If Assigned(FOnTranscriptText) then
    FOnTranscriptText(Self, aFragmentStream, aTransriptText);
end;

function TChatInput.GetContentTypeFromValidExtensions(const Extension: string): TContentType;
var
  CleanExt: string;
begin
  // Limpiar la extensión (quitar el punto si lo tiene)
  CleanExt := Extension;
  if (Length(CleanExt) > 0) and (CleanExt[1] = '.') then
    CleanExt := Copy(CleanExt, 2, Length(CleanExt));

  CleanExt := LowerCase(CleanExt);

  // Detectar tipo por extensión (puedes personalizar esta lógica)
  // Imágenes
  if (CleanExt = 'jpg') or (CleanExt = 'jpeg') or (CleanExt = 'png') or (CleanExt = 'bmp') or (CleanExt = 'gif') or (CleanExt = 'tiff') or (CleanExt = 'webp') then
    Result := ctImage
    // PDF
  else if (CleanExt = 'pdf') then
    Result := ctPDF
    // Audio
  else if (CleanExt = 'mp3') or (CleanExt = 'wav') or (CleanExt = 'm4a') or (CleanExt = 'aac') or (CleanExt = 'flac') or (CleanExt = 'ogg') or (CleanExt = 'wma') then
    Result := ctAudio
    // Video
  else if (CleanExt = 'mp4') or (CleanExt = 'avi') or (CleanExt = 'mov') or (CleanExt = 'wmv') or (CleanExt = 'mkv') or (CleanExt = 'flv') or (CleanExt = 'webm') or (CleanExt = 'm4v') then
    Result := ctVideo
    // Documentos
  else if (CleanExt = 'doc') or (CleanExt = 'docx') or (CleanExt = 'xls') or (CleanExt = 'xlsx') or (CleanExt = 'ppt') or (CleanExt = 'pptx') or (CleanExt = 'rtf') or (CleanExt = 'odt') or (CleanExt = 'ods') or (CleanExt = 'odp') then
    Result := ctDocument
    // Texto y otros
  else if (CleanExt = 'txt') or (CleanExt = 'log') or (CleanExt = 'ini') or (CleanExt = 'cfg') or (CleanExt = 'xml') or (CleanExt = 'json') or (CleanExt = 'csv') or (CleanExt = 'html') or (CleanExt = 'css') or (CleanExt = 'js') or
    (CleanExt = 'sql') or (CleanExt = 'md') then
    Result := ctText
  else
    Result := ctUnknown;
end;

end.

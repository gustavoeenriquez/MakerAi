unit uMakerAi.UI.ChatList;

interface

uses
  System.SysUtils, System.Classes, System.Types, System.UITypes, System.Math.Vectors, System.Math,
  FMX.Types, FMX.Controls, FMX.Graphics, FMX.Layouts, FMX.ScrollBox, FMX.StdCtrls, System.JSON,
  FMX.Memo, FMX.Objects, FMX.Ani, FMX.Styles.Objects, FMX.Menus,
  uMakerAi.UI.ChatBubble, uMakerAi.Core; // Asegúrate de que esta unidad esté en el path de tu proyecto

type
  // Tipos de eventos definidos en la especificación (req. 11)
  TChatListBubbleEvent = procedure(Sender: TObject; ABubble: TChatBubble) of object;
  TChatListCalcEvent = procedure(Sender: TObject; ABubble: TChatBubble; var ASize: TSizeF; var Handled: Boolean) of object;
  TChatListMediaFileEvent = procedure(Sender: TObject; const ABubble: TChatBubble; const AMediaFile: TAiMediaFile) of object;

  TChatList = class(TVertScrollBox)
  private
    FContentLayout: TFlowLayout;
    FLastBubble: TChatBubble;
    FLastUserName: string;

    // Campos para las propiedades publicadas
    FInboundColor: TAlphaColor;
    FOutboundColor: TAlphaColor;
    FAutoScroll: Boolean;
    FMaxBubbleWidthPercent: Single;
    FBubblePadding: TRectF;
    FBubbleMargins: TRectF;
    FDefaultWordWrap: Boolean;
    FGroupConsecutiveMessages: Boolean;

    // Campos para los eventos
    FOnBeforeAddBubble: TChatListBubbleEvent;
    FOnBubbleAdded: TChatListBubbleEvent;
    FOnCalculateBubbleContentSize: TChatListCalcEvent;
    FOnBubbleAvatarClick: TChatListBubbleEvent;
    FOnBubbleExpandCollapseClick: TChatListBubbleEvent;
    FOnBubbleMoreOptionsClick: TChatListBubbleEvent;
    FOnMediaFileDblClick: TChatListMediaFileEvent;
    FAttachmentPopupMenu: TPopupMenu;
    FActiveMediaFile: TAiMediaFile;

    // Setters para las propiedades
    procedure SetInboundColor(const Value: TAlphaColor);
    procedure SetOutboundColor(const Value: TAlphaColor);
    procedure SetMaxBubbleWidthPercent(const Value: Single);
    procedure SetBubblePadding(const Value: TRectF);
    procedure SetBubbleMargins(const Value: TRectF);

    // Métodos internos
    procedure UpdateContentLayoutHeight;
    function IsScrolledToBottom: Boolean;
    procedure InternalAddBubble(ABubble: TChatBubble; const AUserName: string; AInbound: Boolean);
    function TryAppendToLastBubble(ABubble: TChatBubble; const AUserName: string; AInbound: Boolean): Boolean;
    procedure CalculateAndSetBubbleSize(ABubble: TChatBubble);

    // Manejadores de eventos para reenvío (hooking)
    procedure DoBubbleAvatarClick(Sender: TObject);
    procedure DoBubbleExpandCollapseClick(Sender: TObject);
    procedure DoBubbleMoreOptionsClick(Sender: TObject);
    procedure DoCalculateContentSize(Sender: TObject; var AContentSize: TSizeF);
    procedure DoBubbleMediaFileDblClick(Sender: TObject; const AMediaFile: TAiMediaFile);
    procedure DoAttachmentContextPopup(Sender: TObject; const AMediaFile: TAiMediaFile; const MousePos: TPointF);
    procedure DoBubbleRecalculateRequired(Sender: TObject);

    procedure SetAttachmentPopupMenu(const Value: TPopupMenu);

  protected
    procedure Loaded; override;
    procedure Resize; override;

    Procedure SetMemoBackVisible(Memo: TMemo; Value: Boolean);

  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    // API Pública (req. 2)
    // function AddBubble(const AText, AUserName: string; AInbound: Boolean = True): TChatBubble;
    function AddBubble(const AText: string; const AUserName: string; AMediaFiles: TAiMediaFiles; AInbound: Boolean = True): TChatBubble;
    function AddBubbleWithControl(AControl: TControl; const AUserName: string; AInbound: Boolean = True): TChatBubble;
    function AddMemoBubble(const AText: string; const AUserName: string; AInbound: Boolean = True; AWordWrap: Boolean = True): TChatBubble;
    function AddCustomBubble(ABubble: TChatBubble; const AUserName: string; AInbound: Boolean = True): TChatBubble;
    procedure RemoveBubble(ABubble: TChatBubble);
    procedure Clear;
    procedure ScrollToBottom;
    procedure SaveToStream(AStream: TStream);
    procedure LoadFromStream(AStream: TStream);

    property ContentLayout: TFlowLayout read FContentLayout;
    property ActiveMediaFile: TAiMediaFile read FActiveMediaFile;

  published
    // Propiedades importantes (req. 2)
    property InboundColor: TAlphaColor read FInboundColor write SetInboundColor default TAlphaColors.LightGray;
    property OutboundColor: TAlphaColor read FOutboundColor write SetOutboundColor default TAlphaColors.LightGreen;
    property AutoScroll: Boolean read FAutoScroll write FAutoScroll default True;
    property MaxBubbleWidthPercent: Single read FMaxBubbleWidthPercent write SetMaxBubbleWidthPercent;
    property BubblePadding: TRectF read FBubblePadding write SetBubblePadding;
    property BubbleMargins: TRectF read FBubbleMargins write SetBubbleMargins;
    property DefaultWordWrap: Boolean read FDefaultWordWrap write FDefaultWordWrap default False;
    property GroupConsecutiveMessages: Boolean read FGroupConsecutiveMessages write FGroupConsecutiveMessages default True;
    property AttachmentPopupMenu: TPopupMenu read FAttachmentPopupMenu write SetAttachmentPopupMenu;

    // Eventos principales (req. 2 y 7)
    property OnBeforeAddBubble: TChatListBubbleEvent read FOnBeforeAddBubble write FOnBeforeAddBubble;
    property OnBubbleAdded: TChatListBubbleEvent read FOnBubbleAdded write FOnBubbleAdded;
    property OnCalculateBubbleContentSize: TChatListCalcEvent read FOnCalculateBubbleContentSize write FOnCalculateBubbleContentSize;
    property OnBubbleAvatarClick: TChatListBubbleEvent read FOnBubbleAvatarClick write FOnBubbleAvatarClick;
    property OnBubbleExpandCollapseClick: TChatListBubbleEvent read FOnBubbleExpandCollapseClick write FOnBubbleExpandCollapseClick;
    property OnBubbleMoreOptionsClick: TChatListBubbleEvent read FOnBubbleMoreOptionsClick write FOnBubbleMoreOptionsClick;
    property OnMediaFileDblClick: TChatListMediaFileEvent read FOnMediaFileDblClick write FOnMediaFileDblClick;

    // Propiedades heredadas que queremos exponer
    property Align;
    property Anchors;
    property Position;
    property Size;
    property Visible;
    property Enabled;
    property OnClick;
    property OnDblClick;
  end;

procedure Register;

implementation

procedure Register;
begin
  RegisterComponents('MakerAI UI', [TChatList]);
end;

const
  CHAT_FORMAT_VERSION = 1;

  { TChatList }

constructor TChatList.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);

  // 1. Arquitectura general: TVertScrollBox con un TFlowLayout interno
  FContentLayout := TFlowLayout.Create(Self);
  FContentLayout.Parent := Self;
  FContentLayout.Stored := False;
  FContentLayout.Align := TAlignLayout.Top;
  FContentLayout.FlowDirection := TFlowDirection.LeftToRight;
  // Aseguramos que el FlowLayout se ajuste en ancho al viewport
  // FContentLayout.Anchors := [TAnchorKind.akLeft, TAnchorKind.akTop, TAnchorKind.akRight];
  // FContentLayout.Width := Self.Width;

  // Inicialización de propiedades por defecto
  FInboundColor := TAlphaColors.LightGray;
  FOutboundColor := TAlphaColors.LightGreen;
  FAutoScroll := True;
  FMaxBubbleWidthPercent := 0.8; // 80% del ancho
  FBubblePadding := TRectF.Create(8, 8, 8, 8);
  FBubbleMargins := TRectF.Create(5, 5, 5, 5);
  FDefaultWordWrap := True;
  FGroupConsecutiveMessages := True;
end;

destructor TChatList.Destroy;
begin
  // FContentLayout se libera automáticamente al ser hijo de Self
  inherited Destroy;
end;

procedure TChatList.Loaded;
begin
  inherited;
  // Asegurarse de que el layout tiene el ancho correcto al cargar
  FContentLayout.Width := ClientWidth;
  FContentLayout.Height := Self.Height;
end;

procedure TChatList.LoadFromStream(AStream: TStream);
var
  LReader: TStreamReader;
  LJsonString: string;
  LJsonValue: TJSONValue;
  LRoot: TJSONObject;
  LBubblesArray: TJSONArray;
  LBubbleValue: TJSONValue;
  LNewBubble: TChatBubble;
  LVersion: Integer;
  LIsOutbound: Boolean;
begin
  if not Assigned(AStream) or (AStream.Size = 0) then
    Exit;

  AStream.Position := 0;
  LReader := TStreamReader.Create(AStream, TEncoding.UTF8);
  try
    LJsonString := LReader.ReadToEnd;
  finally
    LReader.Free;
  end;

  if LJsonString = '' then
    Exit;

  LJsonValue := TJSONObject.ParseJSONValue(LJsonString);
  if not(LJsonValue is TJSONObject) then
  begin
    if Assigned(LJsonValue) then
      LJsonValue.Free;
    raise Exception.Create('Formato de chat inválido.');
  end;

  LRoot := LJsonValue as TJSONObject;
  try
    if not(LRoot.TryGetValue<Integer>('version', LVersion) and (LVersion = CHAT_FORMAT_VERSION)) then
      raise Exception.Create('Versión del formato de chat no soportada.');

    Self.Clear;
    Self.BeginUpdate;
    try
      if LRoot.TryGetValue<TJSONArray>('bubbles', LBubblesArray) then
      begin
        for LBubbleValue in LBubblesArray do
        begin
          if LBubbleValue is TJSONObject then
          begin
            LNewBubble := TChatBubble.Create(nil);
            try
              LNewBubble.LoadFromJsonObject(LBubbleValue as TJSONObject);

              LIsOutbound := (LNewBubble.TailPosition = tpRight);

              // Volvemos a usar la lógica existente para añadir la burbuja,
              // asegurando que se apliquen colores, márgenes, eventos, etc.
              AddCustomBubble(LNewBubble, LNewBubble.UserName, not LIsOutbound);

            except
              LNewBubble.Free;
              raise;
            end;
          end;
        end;
      end;
    finally
      Self.EndUpdate;
      Self.Resize;
      TThread.ForceQueue(nil,
        procedure
        begin
          ScrollToBottom;
        end);
    end;
  finally
    LRoot.Free;
  end;
end;

procedure TChatList.Resize;
var
  I: Integer;
  LControl: TControl;
  LMemo: TMemo;
begin
  inherited;

  if not Assigned(FContentLayout) then
    Exit;

  // 1. Actualizar el ancho del layout contenedor (esto ya lo tenías).
  FContentLayout.Width := ClientWidth;

  // 2. Iterar sobre todos los controles hijos (las burbujas) y forzar un recálculo de su tamaño.
  // Usamos BeginUpdate/EndUpdate para mejorar el rendimiento y evitar repintados intermedios.
  FContentLayout.BeginUpdate;
  try
    for I := 0 to FContentLayout.ControlsCount - 1 do
    begin
      LControl := FContentLayout.Controls[I];
      // Asegurarnos de que solo procesamos los TChatBubble
      if LControl is TChatBubble then
      begin
        // Llamamos al mismo método que usamos al añadir una burbuja nueva.
        // Este método usará el NUEVO ancho del TChatList para calcular el tamaño.
        CalculateAndSetBubbleSize(LControl as TChatBubble);

        LMemo := TChatBubble(LControl).FindFirstChild<TMemo>;
        if Assigned(LMemo) then
        Begin
          var
            Bg: TFmxObject;
          Bg := LMemo.FindStyleResource('background');

          If Bg is TActiveStyleObject then
            TActiveStyleObject(Bg).Opacity := 0;
        End;

      end;
    end;
  finally
    FContentLayout.EndUpdate;
  end;

  // 3. Después de que todas las burbujas tienen su nuevo tamaño (alto y ancho),
  // recalculamos la altura total del FContentLayout para que el scrollbar sea correcto.
  UpdateContentLayoutHeight;
end;


// --- MÉTODOS PÚBLICOS ---

function TChatList.AddBubble(const AText: string; const AUserName: string; AMediaFiles: TAiMediaFiles; AInbound: Boolean): TChatBubble;
var
  LBubble: TChatBubble;
begin
  // 1. Crear una burbuja vacía
  LBubble := TChatBubble.Create(nil);
  try
    // 2. Usar el nuevo método de TChatBubble para poblarla con contenido
    LBubble.AddContent(AText, AMediaFiles);

    // 3. Llamar al método genérico para añadirla a la lista
    Result := AddCustomBubble(LBubble, AUserName, AInbound);

    Var
    LMemo := Result.FindFirstChild<TMemo>;
    If Assigned(LMemo) then
    Begin

      LMemo.StyleLookup := 'memostyle';
      LMemo.ApplyStyleLookup;
      var
        Bg: TFmxObject;
      Bg := LMemo.FindStyleResource('background');

      If Bg is TActiveStyleObject then
        TActiveStyleObject(Bg).Opacity := 0;

      LBubble.RecalculateSize(LBubble.Width);
    End;

    Self.Resize;
  except
    LBubble.Free; // Liberar si algo falla
    raise;
  end;
end;

function TChatList.AddBubbleWithControl(AControl: TControl; const AUserName: string; AInbound: Boolean): TChatBubble;
var
  LBubble: TChatBubble;
begin
  // Crea una burbuja, le asigna el control y llama al método principal
  if (AControl = nil) or Assigned(AControl.Parent) then
    raise EArgumentException.Create('El control a añadir no puede ser nulo ni tener un padre asignado.');

  LBubble := TChatBubble.Create(nil); // Sin padre, se asignará en InternalAddBubble
  try
    AControl.Parent := LBubble;
    Result := AddCustomBubble(LBubble, AUserName, AInbound);
  except
    LBubble.Free; // AControl se libera junto con LBubble
    raise;
  end;
end;

function TChatList.AddCustomBubble(ABubble: TChatBubble; const AUserName: string; AInbound: Boolean): TChatBubble;
begin
  if (ABubble = nil) or Assigned(ABubble.Parent) then
    raise EArgumentException.Create('La burbuja a añadir no puede ser nula ni tener un padre asignado.');

  // La lógica central de adición está en un método privado para reutilización
  InternalAddBubble(ABubble, AUserName, AInbound);
  Result := ABubble;
end;

function TChatList.AddMemoBubble(const AText: string; const AUserName: string; AInbound: Boolean; AWordWrap: Boolean): TChatBubble;
var
  LMemo: TMemo;
begin
  // Creamos un TMemo en lugar de un TText
  LMemo := TMemo.Create(nil); // Sin padre
  LMemo.Lines.Text := AText;
  LMemo.WordWrap := AWordWrap;
  // Estilos recomendados para un memo en un chat:
  LMemo.StyledSettings := LMemo.StyledSettings - [TStyledSetting.Style, TStyledSetting.Other];
  LMemo.ReadOnly := True;
  LMemo.HitTest := True; // Para que el clic pase a la burbuja
  LMemo.GoToTextBegin;
  LMemo.SelectionFill.Color := TAlphaColors.Null; // Ocultar el color de selección
  LMemo.HideSelectionOnExit := True;

  try
    Result := AddBubbleWithControl(LMemo, AUserName, AInbound);

    // Elimina el fondo del memo para hacerlo transparente
    LMemo.StyleLookup := 'memostyle';
    LMemo.ApplyStyleLookup;

    SetMemoBackVisible(LMemo, False);

  except
    LMemo.Free; // Liberar si la adición falla
    raise;
  end;
end;

procedure TChatList.Clear;
begin
  while FContentLayout.ChildrenCount > 0 do
    FContentLayout.Children[0].Free;

  FLastBubble := nil;
  FLastUserName := '';
  UpdateContentLayoutHeight;
end;

procedure TChatList.RemoveBubble(ABubble: TChatBubble);
begin
  if (ABubble <> nil) and (ABubble.Parent = FContentLayout) then
  begin
    if FLastBubble = ABubble then
    begin
      FLastBubble := nil;
      FLastUserName := '';
      // Opcional: buscar el nuevo "último" bubble
      if FContentLayout.ControlsCount > 1 then
      begin
        var
        LNewLastBubble := FContentLayout.Controls[FContentLayout.ControlsCount - 2] as TChatBubble;
        FLastBubble := LNewLastBubble;
        FLastUserName := LNewLastBubble.UserName;
      end;
    end;
    ABubble.Free;
    UpdateContentLayoutHeight;
  end;
end;

procedure TChatList.SaveToStream(AStream: TStream);
var
  LRoot: TJSONObject;
  LBubblesArray: TJSONArray;
  I: Integer;
  LBubble: TChatBubble;
  LWriter: TStreamWriter;
begin
  if not Assigned(AStream) then
    Exit;

  LRoot := TJSONObject.Create;
  try
    LRoot.AddPair('version', TJSONNumber.Create(CHAT_FORMAT_VERSION));

    LBubblesArray := TJSONArray.Create;
    LRoot.AddPair('bubbles', LBubblesArray);

    for I := 0 to FContentLayout.ControlsCount - 1 do
    begin
      if FContentLayout.Controls[I] is TChatBubble then
      begin
        LBubble := FContentLayout.Controls[I] as TChatBubble;
        LBubblesArray.AddElement(LBubble.ToJsonObject);
      end;
    end;

    LWriter := TStreamWriter.Create(AStream, TEncoding.UTF8); // Siempre usa UTF8
    try
      LWriter.Write(LRoot.ToJSON); // ToJSON es más legible que ToString
    finally
      LWriter.Free;
    end;

  finally
    LRoot.Free;
  end;
end;

procedure TChatList.ScrollToBottom;
begin
  // Usa ForceQueue para asegurar que el layout se ha actualizado antes del scroll
  // Lógica extraída del demo
  TThread.ForceQueue(nil,
    procedure
    begin
      if not Assigned(FContentLayout) then
        Exit;
      var
      LTargetY := FContentLayout.Height - Self.Height;
      if LTargetY > 0 then
      begin
        Self.ViewportPosition := PointF(Self.ViewportPosition.X, LTargetY);
      end;
    end);
end;

// --- MÉTODOS INTERNOS Y PRIVADOS ---

function TChatList.IsScrolledToBottom: Boolean;
const
  TOLERANCE = 5; // Margen de píxeles para considerar que está al final
begin
  Result := (Self.ViewportPosition.Y >= (FContentLayout.Height - Self.Height - TOLERANCE));
end;

procedure TChatList.InternalAddBubble(ABubble: TChatBubble; const AUserName: string; AInbound: Boolean);
var
  LShouldScroll: Boolean;
begin
  // 5. Flujo al añadir un bubble
  // Determinar si hay que hacer scroll ANTES de añadir el nuevo contenido
  LShouldScroll := FAutoScroll or IsScrolledToBottom;

  // 6. Agrupamiento / Append
  if FGroupConsecutiveMessages and TryAppendToLastBubble(ABubble, AUserName, AInbound) then
  begin
    ABubble.Free; // El bubble pasado no se usó, se liberó su contenido dentro de TryAppend
    if LShouldScroll then
      ScrollToBottom;
    Exit;
  end;

  // Configuración del nuevo bubble
  ABubble.UserName := AUserName;
  ABubble.Title := AUserName; // Por defecto el título es el nombre de usuario
  ABubble.Timestamp := FormatDateTime('hh:nn', Now);

  If AInbound then
    ABubble.TailPosition := TChatBubbleTailPosition.tpLeft
  else
    ABubble.TailPosition := TChatBubbleTailPosition.tpRight;

  ABubble.BubbleColor := IfThen(AInbound, FInboundColor, FOutboundColor);
  ABubble.Padding.Rect := FBubblePadding;
  ABubble.Margins.Rect := FBubbleMargins;

  if Assigned(FOnBeforeAddBubble) then
    FOnBeforeAddBubble(Self, ABubble);

  CalculateAndSetBubbleSize(ABubble);

  // Asignar padre y enganchar eventos
  ABubble.Parent := FContentLayout;

  // 7. Reenvío de eventos
  ABubble.OnAvatarClick := DoBubbleAvatarClick;
  ABubble.OnExpandCollapseClick := DoBubbleExpandCollapseClick;
  ABubble.OnMoreOptionsClick := DoBubbleMoreOptionsClick;
  ABubble.OnMediaFileDblClick := DoBubbleMediaFileDblClick;
  ABubble.OnAttachmentContextPopup := DoAttachmentContextPopup;
  ABubble.OnRecalculateRequired := DoBubbleRecalculateRequired;

  // Redirigir el evento de cálculo de tamaño del bubble a nuestro propio sistema
  // ABubble.OnCalculateContentSize := DoCalculateContentSize;

  FLastBubble := ABubble;
  FLastUserName := AUserName;

  UpdateContentLayoutHeight;

  if Assigned(FOnBubbleAdded) then
    FOnBubbleAdded(Self, ABubble);

  if LShouldScroll then
    ScrollToBottom;
end;

procedure TChatList.CalculateAndSetBubbleSize(ABubble: TChatBubble);
var
  LMaxWidthForBubble: Single;
  LBubbleHorzMargins: Single;
begin
  // 1. Calcular los márgenes horizontales que la propia burbuja va a añadir.
  // Estos están definidos por la propiedad FBubbleMargins del TChatList.
  LBubbleHorzMargins := FBubbleMargins.Left + FBubbleMargins.Right;

  // 2. Calcular el ancho máximo disponible para la burbuja,
  // Y RESTARLE el espacio que ocuparán sus propios márgenes.
  if Self.ClientWidth > 0 then
    LMaxWidthForBubble := (Self.ClientWidth * FMaxBubbleWidthPercent) - LBubbleHorzMargins
  else
    LMaxWidthForBubble := 200; // Un valor por defecto

  // Asegurarnos de que el ancho no sea negativo si la ventana es muy pequeña.
  if LMaxWidthForBubble < 0 then
    LMaxWidthForBubble := 0;

  // 3. Delegar el cálculo de tamaño a la propia burbuja, pasándole
  // el ancho corregido que debe tener su propiedad .Width.
  ABubble.RecalculateSize(LMaxWidthForBubble);
end;

{
  function TChatList.TryAppendToLastBubble(ABubble: TChatBubble; const AUserName: string; AInbound: Boolean): Boolean;
  var
  LTargetText: TText;
  LTargetMemo: TMemo; // <-- Nueva variable
  LSourceText: TText;
  LSourceMemo: TMemo; // <-- Nueva variable
  LNewText: string;
  begin
  Result := False;
  if (FLastBubble = nil) or (FLastUserName <> AUserName) then
  Exit;

  // Comprobación adicional (ya la tenías comentada, pero es buena idea tenerla)
  // para asegurar que el mensaje entrante/saliente coincide con el anterior.
  // if FLastBubble.TailPosition <> IfThen(AInbound, TChatBubbleTailPosition.tpLeft, TChatBubbleTailPosition.tpRight) then  Exit;

  // --- LÓGICA DE FUSIÓN MODIFICADA ---

  // Primero, intentamos fusionar TMemo con TMemo.
  LTargetMemo := FLastBubble.FindFirstChild<TMemo>;
  LSourceMemo := ABubble.FindFirstChild<TMemo>;
  if (LTargetMemo <> nil) and (LSourceMemo <> nil) then
  begin
  LNewText := LSourceMemo.Lines.Text;
  // Añadimos el nuevo texto con un salto de línea.
  LTargetMemo.Lines.Add(LNewText);
  FLastBubble.Timestamp := FormatDateTime('hh:nn', Now);

  // Recalcular tamaño de la burbuja existente
  CalculateAndSetBubbleSize(FLastBubble);
  UpdateContentLayoutHeight;
  Result := True;
  Exit; // ¡Importante! Salimos si ya hemos fusionado.
  end;

  // Si no se pudo fusionar TMemo, intentamos TText con TText (tu lógica original).
  LTargetText := FLastBubble.FindFirstChild<TText>;
  LSourceText := ABubble.FindFirstChild<TText>;
  if (LTargetText <> nil) and (LSourceText <> nil) then
  begin
  LNewText := LSourceText.Text;
  LTargetText.Text := LTargetText.Text + sLineBreak + LNewText;
  FLastBubble.Timestamp := FormatDateTime('hh:nn', Now);

  // Recalcular tamaño de la burbuja existente
  CalculateAndSetBubbleSize(FLastBubble);
  UpdateContentLayoutHeight;
  Result := True;
  // No es necesario Exit aquí porque es la última comprobación.
  end;
  end;
}

function TChatList.TryAppendToLastBubble(ABubble: TChatBubble; const AUserName: string; AInbound: Boolean): Boolean;
var
  LTargetMemo, LSourceMemo: TMemo;
begin
  Result := False;

  // --- Reglas de Salida Inmediata (las que ya tenías están bien) ---
  if not FGroupConsecutiveMessages then
    Exit;
  if (FLastBubble = nil) or (FLastUserName <> AUserName) then
    Exit;
  // if FLastBubble.TailPosition <> IfThen(AInbound, TChatBubbleTailPosition.tpLeft, TChatBubbleTailPosition.tpRight) then Exit;

  // --- NUEVAS REGLAS DE VALIDACIÓN ESTRICTA ---
  // Un mensaje con contenido mixto (imágenes, etc.) NUNCA debe ser fusionado.
  // La forma más simple de saberlo es contando sus hijos. Un mensaje de solo texto tiene 1 hijo (el TMemo).

  // Regla 1: La burbuja de origen (la nueva) debe contener únicamente un TMemo.
  if ABubble.ContentLayout.ChildrenCount <> 1 then
    Exit; // Tiene imágenes, adjuntos, o está vacía. No fusionar.
  LSourceMemo := ABubble.FindFirstChild<TMemo>;
  if not Assigned(LSourceMemo) then
    Exit; // Su único hijo no es un TMemo. No fusionar.

  // Regla 2: La burbuja de destino (la última en el chat) también debe contener únicamente un TMemo.
  if FLastBubble.ContentLayout.ChildrenCount <> 1 then
    Exit; // La burbuja anterior ya tiene contenido mixto. No añadirle más.
  LTargetMemo := FLastBubble.FindFirstChild<TMemo>;
  if not Assigned(LTargetMemo) then
    Exit; // La burbuja anterior no es de solo texto. No fusionar.


  // --- LÓGICA DE FUSIÓN (Solo se ejecuta si todas las reglas anteriores se cumplen) ---
  // Si llegamos aquí, sabemos que LSourceMemo y LTargetMemo son válidos.

  // Añadimos el nuevo texto con un salto de línea. Usamos Add para mayor seguridad.
  LTargetMemo.Lines.Add(LSourceMemo.Lines.Text);
  FLastBubble.Timestamp := FormatDateTime('hh:nn', Now);

  // Recalcular tamaño de la burbuja existente
  FLastBubble.RecalculateSize(Self.Width);
  // Si no tienes RecalculateBubble, usa estas dos líneas:
  // CalculateAndSetBubbleSize(FLastBubble);
  // UpdateContentLayoutHeight;

  Result := True;

  // Nota: Ya no necesitamos la sección para TText, ya que ahora todo el texto
  // se maneja a través de TMemo gracias a la refactorización.
  // Puedes eliminar esa parte del código de forma segura.
end;

procedure TChatList.UpdateContentLayoutHeight;
var
  TotalHeight: Single;
  I: Integer;
  Control: TControl;
begin
  // Lógica extraída del demo para ajustar la altura del contenedor
  TotalHeight := 0;
  for I := 0 to FContentLayout.ControlsCount - 1 do
  begin
    Control := FContentLayout.Controls[I];
    TotalHeight := TotalHeight + Control.Height + Control.Margins.Top + Control.Margins.Bottom;
  end;
  FContentLayout.Height := TotalHeight + FContentLayout.Padding.Top + FContentLayout.Padding.Bottom;
end;

procedure TChatList.SetAttachmentPopupMenu(const Value: TPopupMenu);
begin
  FAttachmentPopupMenu := Value;
end;

// --- SETTERS ---

procedure TChatList.SetBubbleMargins(const Value: TRectF);
begin
  FBubbleMargins := Value;
end;

procedure TChatList.SetBubblePadding(const Value: TRectF);
begin
  FBubblePadding := Value;
end;

procedure TChatList.SetInboundColor(const Value: TAlphaColor);
begin
  FInboundColor := Value;
end;

procedure TChatList.SetMaxBubbleWidthPercent(const Value: Single);
begin
  FMaxBubbleWidthPercent := EnsureRange(Value, 0.1, 1.0);
end;

procedure TChatList.SetMemoBackVisible(Memo: TMemo; Value: Boolean);
var
  Bg: TFmxObject;
begin
  Bg := Memo.FindStyleResource('background');

  If Bg is TActiveStyleObject then
    TActiveStyleObject(Bg).Opacity := 0;

end;

procedure TChatList.SetOutboundColor(const Value: TAlphaColor);
begin
  FOutboundColor := Value;
end;

procedure TChatList.DoAttachmentContextPopup(Sender: TObject; const AMediaFile: TAiMediaFile; const MousePos: TPointF);
begin
  // 1. Guardamos el archivo sobre el que se hizo clic.
  // Ahora está disponible públicamente a través de TChatList.ActiveMediaFile
  FActiveMediaFile := AMediaFile;

  // 2. Si el usuario ha asignado un menú, lo mostramos.
  if Assigned(FAttachmentPopupMenu) then
  begin
    // OPCIONAL pero RECOMENDADO: Dar al usuario la oportunidad de preparar el menú
    // (por ejemplo, habilitar/deshabilitar items) a través de un evento.
    // FAttachmentPopupMenu.TagObject := AMediaFile; // Otra forma de pasar la info
    FAttachmentPopupMenu.Popup(MousePos.X, MousePos.Y);
  end;

  // 3. Importante: Limpiamos la referencia después de que el menú se cierre.
  // Lo hacemos con un TThread.ForceQueue para que se ejecute después de la acción del menú.
  TThread.ForceQueue(nil,
    procedure
    begin
      // FActiveMediaFile := nil;
    end);
end;

// --- MANEJADORES DE REENVÍO DE EVENTOS ---

procedure TChatList.DoBubbleAvatarClick(Sender: TObject);
begin
  if Assigned(FOnBubbleAvatarClick) then
    FOnBubbleAvatarClick(Self, Sender as TChatBubble);
end;

{
  procedure TChatList.DoBubbleExpandCollapseClick(Sender: TObject);
  begin
  if Assigned(FOnBubbleExpandCollapseClick) then
  FOnBubbleExpandCollapseClick(Self, Sender as TChatBubble);
  end;
}

procedure TChatList.DoBubbleExpandCollapseClick(Sender: TObject);
var
  ABubble: TChatBubble;
  TargetY: Single;
  ViewportHeight: Single;
  BubbleTop: Single;
begin
  // Primero, disparamos el evento público para que el usuario del componente
  // pueda ejecutar su propia lógica si lo necesita.
  if Assigned(FOnBubbleExpandCollapseClick) then
    FOnBubbleExpandCollapseClick(Self, Sender as TChatBubble);

  // --- INICIO DE LA LÓGICA DE AUTO-SCROLL ---

  // El tamaño de la burbuja ha cambiado, así que necesitamos recalcular
  // la altura total del layout de contenido.
  UpdateContentLayoutHeight;

  // Hacemos el casting del Sender a TChatBubble para trabajar con él.
  ABubble := Sender as TChatBubble;
  if not Assigned(ABubble) then
    Exit;

  // Usamos TThread.Queue para que la lógica de cálculo de posición se ejecute
  // DESPUÉS de que el motor de FMX haya actualizado visualmente el layout.
  // Esto es crucial para obtener las coordenadas correctas de ABubble.Position.
  TThread.Queue(nil,
    procedure
    begin
      // Doble chequeo de seguridad dentro del hilo
      if Self.IsUpdating or (ABubble = nil) then
        Exit;

      // El scrollbox es el propio componente (Self)
      ViewportHeight := Self.Height;
      BubbleTop := ABubble.Position.Y;

      // Optimización: Si la burbuja ya está completamente visible, no hacemos nada.
      if (BubbleTop >= Self.ViewportPosition.Y) and ((BubbleTop + ABubble.Height) <= (Self.ViewportPosition.Y + ViewportHeight)) then
      begin
        Exit; // Ya es visible, no se necesita scroll.
      end;

      // Calculamos la posición Y de destino para centrar la burbuja en el viewport.
      TargetY := BubbleTop - (ViewportHeight / 2) + (ABubble.Height / 2);

      // Nos aseguramos de no salirnos de los límites del scroll.
      if TargetY < 0 then
        TargetY := 0;

      if TargetY > FContentLayout.Height - ViewportHeight then
        TargetY := FContentLayout.Height - ViewportHeight;

      // Caso especial: si el contenido total es más pequeño que el área visible,
      // la posición del scroll siempre debe ser 0.
      if FContentLayout.Height <= ViewportHeight then
        TargetY := 0;

      // Animamos el cambio de ViewportPosition.Y para un desplazamiento suave.
      TAnimator.AnimateFloat(Self, 'ViewportPosition.Y', TargetY, 0.3, TAnimationType.InOut, TInterpolationType.Quadratic);
    end);
end;

procedure TChatList.DoBubbleMediaFileDblClick(Sender: TObject; const AMediaFile: TAiMediaFile);
begin
  if Assigned(FOnMediaFileDblClick) then
    FOnMediaFileDblClick(Self, Sender as TChatBubble, AMediaFile);
end;

procedure TChatList.DoBubbleMoreOptionsClick(Sender: TObject);
begin
  if Assigned(FOnBubbleMoreOptionsClick) then
    FOnBubbleMoreOptionsClick(Self, Sender as TChatBubble);
end;

procedure TChatList.DoBubbleRecalculateRequired(Sender: TObject);
var
  ABubble: TChatBubble;
  LShouldScroll: Boolean;
begin
  if not(Sender is TChatBubble) then
    Exit;

  ABubble := Sender as TChatBubble;

  // Guardamos si debemos hacer scroll ANTES de recalcular la altura total,
  // ya que después del recálculo, es posible que ya no estemos "al final".
  LShouldScroll := FAutoScroll and IsScrolledToBottom;

  // 1. Reutilizamos la misma función que usamos al añadir una burbuja nueva.
  // Esto asegura que el redimensionamiento sea consistente.
  CalculateAndSetBubbleSize(ABubble);

  // 2. Después de que la burbuja cambia su altura, la altura total del
  // contenido de la lista también cambia. La actualizamos.
  UpdateContentLayoutHeight;

  // 3. Si estábamos al final de la lista, nos aseguramos de seguir ahí
  // para que el nuevo texto sea visible.
  if LShouldScroll then
    ScrollToBottom;
end;

procedure TChatList.DoCalculateContentSize(Sender: TObject; var AContentSize: TSizeF);
var
  LHandled: Boolean;
begin
  LHandled := False;

  // Este es el evento original de TChatBubble. Lo reenviamos al evento
  // más completo de TChatList que incluye el parámetro 'Handled'.
  if Assigned(FOnCalculateBubbleContentSize) then
  begin
    FOnCalculateBubbleContentSize(Self, Sender as TChatBubble, AContentSize, LHandled);
  end;
end;

end.

unit uMakerAi.Agents;

interface

uses
  System.SysUtils, System.Classes, System.Generics.Collections, System.Generics.Defaults, System.TypInfo,
  System.Bindings.Evaluator, System.Bindings.Helper, System.Bindings.Expression, System.Bindings.Consts,
  System.JSON, System.Math,
  System.Bindings.EvalSys, System.Bindings.Factories, System.Bindings.EvalProtocol, System.Bindings.ObjEval,
  System.Threading, System.Rtti, System.SyncObjs, System.Types, System.StrUtils;

type

{$RTTI INHERIT}
  TMsgState = (msYes, msNo, msOK, msCancel, msAbort, msRetry, msIgnore, msAll, msNoToAll, msYesToAll, msHelp, msClose);
  TMsgStates = set of TMsgState;

  // Modo de unión para los nodos
  TJoinMode = (jmAny, jmAll);

  // Modo de ejecución del enlace
  TLinkMode = (lmFanout, lmConditional, lmManual, lmExpression); // --- NUEVO: Modo lmExpression ---

  // Forward Declarations
  TAIAgents = class;
  TAIAgentsBase = class;
  TAIAgentsNode = class;
  TAIAgentsLink = class;
  TAIBlackboard = class;
  TAiToolBase = Class;

  TAIAgentsOnPrint = procedure(Sender: TObject; Value: String) of object;
  TAgentPrintRef = reference to procedure(Sender: TObject; Value: String);

  TAIAgentsOnEnd = procedure(Node: TAIAgentsNode; Value: string) of object;
  TAIAgentsNodeOnExecute = procedure(Node, BeforeNode: TAIAgentsNode; Link: TAIAgentsLink; Input: String; var Output: String) of object;
  TAIAgentsLinkOnExecute = procedure(Node: TAIAgentsNode; Link: TAIAgentsLink; var IsOk: Boolean; var Handled: Boolean) of object;
  TAIAgentsOnError = procedure(Sender: TObject; Node: TAIAgentsNode; Link: TAIAgentsLink; E: Exception; var Abort: Boolean) of object;
  TAIAgentsOnConfirm = procedure(Sender: TObject; Node: TAIAgentsNode; const AQuestion: string; Buttons: TMsgStates; var AResponse: string; var AModalResult: TMsgState) of object;

  TAIAgentsOnEnterNode = procedure(Sender: TObject; Node: TAIAgentsNode) of object;
  TAIAgentsOnExitNode = procedure(Sender: TObject; Node: TAIAgentsNode) of object;
  TAIAgentsOnStart = procedure(Sender: TObject; const Input: string) of object;
  TAIAgentsOnFinish = procedure(Sender: TObject; const Input, Output: string; Status: string; E: Exception) of object;

  // --- Blackboard ---
  TAIBlackboard = class(TObject)
  private
    FLock: TCriticalSection;
  protected // --- MODIFICADO: protected para acceso desde la misma unidad ---
    FData: TDictionary<string, TValue>;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Clear;
    procedure SetValue(const AKey: string; const AValue: TValue);
    function TryGetValue(const AKey: string; out AValue: TValue): Boolean;
    procedure SetString(const AKey, AValue: string);
    function GetString(const AKey: string; const ADefault: string = ''): string;
    procedure SetInteger(const AKey: string; AValue: Integer);
    function GetInteger(const AKey: string; const ADefault: Integer = 0): Integer;
    procedure SetBoolean(const AKey: string; AValue: Boolean);
    function GetBoolean(const AKey: string; const ADefault: Boolean = False): Boolean;
  end;

  TAiToolBase = class(TComponent)
  private
    FDescription: string;
    procedure SetDescription(const Value: String);
  protected
    procedure Execute(ANode: TAIAgentsNode; const AInput: string; var AOutput: string); virtual; abstract;
  public
    procedure Run(ANode: TAIAgentsNode; const AInput: string; var AOutput: string);
  published
    property Description: string read FDescription write SetDescription;
  end;

  TAiAgentsToolSample = class(TAiToolBase)
  protected
    procedure Execute(ANode: TAIAgentsNode; const AInput: string; var AOutput: string); override;
  end;

  // --- Base Component ---
  TAIAgentsBase = class(TComponent)
  private
    FDescription: String;
    procedure SetDescription(const Value: String);
  Published
    Property Description: String read FDescription write SetDescription;
    Property ID : String;
  end;

  // --- Link (Edge) ---
  TAIAgentsLink = class(TAIAgentsBase)
  private
    FNextNo: TAIAgentsNode;
    FNextB: TAIAgentsNode;
    FNextC: TAIAgentsNode;
    FNextA: TAIAgentsNode;
    FNextD: TAIAgentsNode;
    FGraph: TAIAgents;
    FOnExecute: TAIAgentsLinkOnExecute;
    FNoCycles: Integer;
    FMaxCycles: Integer;
    FReady: Boolean;
    FSourceNode: TAIAgentsNode;
    FConditionalTargets: TDictionary<string, TAIAgentsNode>;
    FMode: TLinkMode;
    FConditionalKey: string;
    FManualTargetsKey: string;
    // --- NUEVO: Campos para el modo lmExpression ---
    FExpressionA: string;
    FExpressionB: string;
    FExpressionC: string;
    FExpressionD: string;
    procedure SetNextA(const Value: TAIAgentsNode);
    procedure SetNextB(const Value: TAIAgentsNode);
    procedure SetNextC(const Value: TAIAgentsNode);
    procedure SetNextD(const Value: TAIAgentsNode);
    procedure SetNextNo(const Value: TAIAgentsNode);
    procedure SetGraph(const Value: TAIAgents);
    procedure SetOnExecute(const Value: TAIAgentsLinkOnExecute);
    procedure SetMaxCycles(const Value: Integer);
    procedure SetMode(const Value: TLinkMode);
  protected
    property Ready: Boolean read FReady write FReady;
    property NoCycles: Integer read FNoCycles write FNoCycles;
    procedure BuildManualTargets(const TargetsCSV: string; out Nodes: TList<TAIAgentsNode>);
    procedure CreateAndQueueTask(ANodeToExecute, ASourceNode: TAIAgentsNode; ACurrentLink: TAIAgentsLink);
  public
    constructor Create(aOwner: TComponent); override;
    destructor Destroy; override;
    procedure Print(Value: String);
    procedure DoExecute(Sender: TAIAgentsNode); // --- MODIFICADO: Ahora es el único método de ejecución
    procedure AddConditionalTarget(const AKey: string; ANode: TAIAgentsNode);
  published
    property NextA: TAIAgentsNode read FNextA write SetNextA;
    property NextB: TAIAgentsNode read FNextB write SetNextB;
    property NextC: TAIAgentsNode read FNextC write SetNextC;
    property NextD: TAIAgentsNode read FNextD write SetNextD;
    property NextNo: TAIAgentsNode read FNextNo write SetNextNo;
    property Graph: TAIAgents read FGraph write SetGraph;
    property OnExecute: TAIAgentsLinkOnExecute read FOnExecute write SetOnExecute;
    property MaxCycles: Integer read FMaxCycles write SetMaxCycles default 1;
    property Mode: TLinkMode read FMode write SetMode default lmFanout;
    property ConditionalKey: string read FConditionalKey write FConditionalKey;
    property ManualTargetsKey: string read FManualTargetsKey write FManualTargetsKey;
    // --- NUEVO: Propiedades para el modo lmExpression ---
    property ExpressionA: string read FExpressionA write FExpressionA;
    property ExpressionB: string read FExpressionB write FExpressionB;
    property ExpressionC: string read FExpressionC write FExpressionC;
    property ExpressionD: string read FExpressionD write FExpressionD;
  end;

  // --- Node ---
  TAIAgentsNode = class(TAIAgentsBase)
  private
    FOutput: String;
    FInput: String;
    FNext: TAIAgentsLink;
    FGraph: TAIAgents;
    FInEdges: TList<TAIAgentsLink>;
    FOnExecute: TAIAgentsNodeOnExecute;
    FPromptName: String;
    FMsgError: String;
    FError: Boolean;
    FJoinLock: TCriticalSection;
    FJoinMode: TJoinMode;
    FTool: TAiToolBase;
    // --- NUEVO: Almacenamiento para las entradas de jmAll ---
    FJoinInputs: TDictionary<TAIAgentsLink, string>;
    procedure SetInput(const Value: String);
    procedure SetNext(const Value: TAIAgentsLink);
    procedure SetOutput(const Value: String);
    procedure SetGraph(const Value: TAIAgents);
    procedure SetOnExecute(const Value: TAIAgentsNodeOnExecute);
    procedure SetPromptName(const Value: String);
    procedure SetJoinMode(const Value: TJoinMode);
    procedure SetTool(const Value: TAiToolBase);
  protected
    procedure DoExecute(aBeforeNode: TAIAgentsNode; aLink: TAIAgentsLink); virtual;
    procedure Reset;
  public
    constructor Create(aOwner: TComponent); override;
    destructor Destroy; override;
    procedure Print(Value: String);
    procedure ForceFinalExecute;
    function RequestConfirmation(const AQuestion: string; Buttons: TMsgStates; var AResponse: string): TMsgState;
    function RequestInput(const ACaption, APrompt: string; var AValue: string): Boolean;
    property Error: Boolean read FError;
    property MsgError: String read FMsgError;
  published
    property Input: String read FInput write SetInput;
    property Output: String read FOutput write SetOutput;
    property Next: TAIAgentsLink read FNext write SetNext;
    property Graph: TAIAgents read FGraph write SetGraph;
    property OnExecute: TAIAgentsNodeOnExecute read FOnExecute write SetOnExecute;
    property PromptName: String read FPromptName write SetPromptName;
    property JoinMode: TJoinMode read FJoinMode write SetJoinMode default jmAny;
    property Tool: TAiToolBase read FTool write SetTool;
  end;

  // --- Orchestrator ---
  TAIAgents = class(TComponent)
  private
    FEndNode: TAIAgentsNode;
    FStartNode: TAIAgentsNode;
    FOnPrint: TAIAgentsOnPrint;
    FOnPrintRef: TAgentPrintRef;
    FNodes: TList<TAIAgentsNode>;
    FLinks: TList<TAIAgentsLink>;
    FOnEnd: TAIAgentsOnEnd;
    FOnError: TAIAgentsOnError;
    FOnConfirm: TAIAgentsOnConfirm;
    FBusy: Boolean;
    FAbort: Boolean;
    FBlackboard: TAIBlackboard;
    FCompiled: Boolean;
    FActiveTasks: TList<ITask>;
    FActiveTasksLock: TCriticalSection;
    FOnExitNode: TAIAgentsOnExitNode;
    FOnEnterNode: TAIAgentsOnEnterNode;
    FMaxConcurrentTasks: Integer;
    FTimeoutMs: Cardinal;
    FOnFinish: TAIAgentsOnFinish;
    FOnStart: TAIAgentsOnStart;
    FDescription: String;
    procedure SetMaxConcurrentTasks(const Value: Integer);
    procedure SetEndNode(const Value: TAIAgentsNode);
    procedure SetStartNode(const Value: TAIAgentsNode);
    procedure SetOnPrint(const Value: TAIAgentsOnPrint);
    procedure SetOnEnd(const Value: TAIAgentsOnEnd);
    procedure SetOnError(const Value: TAIAgentsOnError);
    procedure SetOnConfirm(const Value: TAIAgentsOnConfirm);
    procedure SetOnEnterNode(const Value: TAIAgentsOnEnterNode);
    procedure SetOnExitNode(const Value: TAIAgentsOnExitNode);
    procedure SetOnFinish(const Value: TAIAgentsOnFinish);
    procedure SetOnStart(const Value: TAIAgentsOnStart);
    procedure SetDescription(const Value: String);
  protected
    // --- CORREGIDO: TThreadPool ---
    FThreadPool: TThreadPool;
    procedure DoPrint(Sender: TObject; Value: String);
    procedure DoPrintFromRef(Sender: TObject; Value: String);
    procedure AddComponentToList(AComponent: TAIAgentsBase);
    procedure RemoveComponentFromList(AComponent: TAIAgentsBase);
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
  public
    constructor Create(aOwner: TComponent); override;
    destructor Destroy; override;
    procedure Abort;
    function Run(Msg: String): ITask;
    function FindNode(const AName: string): TAIAgentsNode;
    procedure DoError(Node: TAIAgentsNode; Link: TAIAgentsLink; E: Exception);
    function DoConfirm(Node: TAIAgentsNode; const AQuestion: string; Buttons: TMsgStates; var AResponse: string): TMsgState;

    procedure SetOnPrintEvent(const APrintProc: TAgentPrintRef);
    procedure ClearGraph;
    function AddNode(const AName: string; AExecuteProc: TAIAgentsNodeOnExecute): TAIAgents;
    function AddEdge(const AStartNodeName, AEndNodeName: string): TAIAgents;
    function AddConditionalEdge(const AStartNodeName: string; const AConditionalLinkName: string; AConditionalTargets: TDictionary<string, string>): TAIAgents;
    function SetEntryPoint(const ANodeName: string): TAIAgents;
    function SetFinishPoint(const ANodeName: string): TAIAgents;
    procedure Compile;
    procedure SaveToStream(AStream: TStream);
    Procedure LoadFromStream(AStream: TStream);
    procedure SaveStateToStream(AStream: TStream);
    procedure LoadStateFromStream(AStream: TStream);

    property Busy: Boolean read FBusy;
    property Blackboard: TAIBlackboard read FBlackboard;
  published
    property StartNode: TAIAgentsNode read FStartNode write SetStartNode;
    property EndNode: TAIAgentsNode read FEndNode write SetEndNode;
    property OnPrint: TAIAgentsOnPrint read FOnPrint write SetOnPrint;
    property OnEnd: TAIAgentsOnEnd read FOnEnd write SetOnEnd;
    property OnError: TAIAgentsOnError read FOnError write SetOnError;
    property OnConfirm: TAIAgentsOnConfirm read FOnConfirm write SetOnConfirm;
    property OnEnterNode: TAIAgentsOnEnterNode read FOnEnterNode write SetOnEnterNode;
    property OnExitNode: TAIAgentsOnExitNode read FOnExitNode write SetOnExitNode;
    property MaxConcurrentTasks: Integer read FMaxConcurrentTasks write SetMaxConcurrentTasks default 4;
    property OnStart: TAIAgentsOnStart read FOnStart write SetOnStart;
    property OnFinish: TAIAgentsOnFinish read FOnFinish write SetOnFinish;
    property TimeoutMs: Cardinal read FTimeoutMs write FTimeoutMs default 60000;
    Property Description: String read FDescription write SetDescription;
  end;

function EvalCondition(const Expr: string; Vars: TDictionary<string, TValue>): Boolean;

procedure Register;

implementation

uses uMakerAi.Agents.EngineRegistry;

procedure Register;
begin
  RegisterComponents('MakerAI', [TAIAgents, TAIAgentsNode, TAIAgentsLink, TAiAgentsToolSample]);
end;

function EvalCondition(const Expr: string; Vars: TDictionary<string, TValue>): Boolean;
var
  Scope: TDictionaryScope;
  BindingExpression: TBindingExpression;
  Pair: TPair<string, TValue>;
  Value: TValue;
  ValueWrapper: IValue;
begin
  Scope := TDictionaryScope.Create;
  try
    for Pair in Vars do
    begin
      ValueWrapper := TValueWrapper.Create(Pair.Value);
      Scope.Map.Add(Pair.Key, ValueWrapper);
    end;

    BindingExpression := TBindings.CreateExpression([Scope], Expr);
    try
      ValueWrapper := BindingExpression.Evaluate;
      Value := ValueWrapper.GetValue;

      if Value.IsType<Boolean> then
        Result := Value.AsBoolean
      else
        raise Exception.CreateFmt('La expresión "%s" no devolvió un Boolean', [Expr]);
    finally
      BindingExpression.Free;
    end;
  finally
    Scope.Free;
  end;
end;

function SerializeToolProperties(ATool: TAiToolBase): TJSONObject;
var
  LContext: TRttiContext;
  LRttiType: TRttiType;
  LProp: TRttiProperty;
  LValue: TValue;
begin
  Result := TJSONObject.Create;
  if not Assigned(ATool) then
    Exit;

  LContext := TRttiContext.Create;
  try
    LRttiType := LContext.GetType(ATool.ClassType);
    for LProp in LRttiType.GetProperties do
    begin
      // Solo nos interesan las propiedades que se pueden leer y escribir
      if not(LProp.IsReadable and LProp.IsWritable and (LProp.Visibility = mvPublished)) then
        Continue;

      LValue := LProp.GetValue(ATool);
      if LValue.IsEmpty then
        Continue;

      // Convertir el TValue a un tipo JSON compatible
      case LValue.Kind of
        tkInteger, tkInt64:
          Result.AddPair(LProp.Name, TJSONNumber.Create(LValue.AsInt64));
        tkFloat:
          Result.AddPair(LProp.Name, TJSONNumber.Create(LValue.AsExtended));
        tkString, tkUString, tkLString, tkWString:
          Result.AddPair(LProp.Name, TJSONString.Create(LValue.AsString));
        tkEnumeration:
          if LProp.PropertyType.Handle = TypeInfo(Boolean) then
            Result.AddPair(LProp.Name, TJSONBool.Create(LValue.AsBoolean))
          else // Guardar otros enums por su nombre de texto
            Result.AddPair(LProp.Name, TJSONString.Create(GetEnumName(LProp.PropertyType.Handle, LValue.AsOrdinal)));
      end;
    end;
  finally
    LContext.Free;
  end;
end;

procedure DeserializeToolProperties(ATool: TAiToolBase; APropertiesJSON: TJSONObject);
var
  LContext: TRttiContext;
  LRttiType: TRttiType;
  LProp: TRttiProperty;
  LValue: TValue;
  LPair: TJSONPair;
  LJsonValue: TJSONValue;
  OrdValue: Integer;
begin
  if not Assigned(ATool) or not Assigned(APropertiesJSON) then
    Exit;

  LContext := TRttiContext.Create;
  try
    LRttiType := LContext.GetType(ATool.ClassType);
    for LPair in APropertiesJSON do
    begin
      LProp := LRttiType.GetProperty(LPair.JsonString.Value);
      if Assigned(LProp) and LProp.IsWritable then
      begin
        LJsonValue := LPair.JsonValue;
        LValue := TValue.Empty; // Inicializar

        case LProp.PropertyType.TypeKind of
          tkInteger:
            LValue := TValue.From<Integer>((LJsonValue as TJSONNumber).AsInt);
          tkInt64:
            LValue := TValue.From<Int64>((LJsonValue as TJSONNumber).AsInt64);
          tkFloat:
            LValue := TValue.From<Double>((LJsonValue as TJSONNumber).AsDouble);
          tkString, tkUString, tkLString, tkWString:
            LValue := TValue.From<string>((LJsonValue as TJSONString).Value);
          tkEnumeration:
            if LProp.PropertyType.Handle = TypeInfo(Boolean) then
              LValue := TValue.From<Boolean>((LJsonValue as TJSONBool).AsBoolean)
            else
            begin
              OrdValue := GetEnumValue(LProp.PropertyType.Handle, (LJsonValue as TJSONString).Value);
              if OrdValue >= 0 then
                LValue := TValue.FromOrdinal(LProp.PropertyType.Handle, OrdValue);
            end;
        end;

        if not LValue.IsEmpty then
          LProp.SetValue(ATool, LValue);
      end;
    end;
  finally
    LContext.Free;
  end;
end;

procedure SerializeBlackboard(ABlackboard: TAIBlackboard; AJSONObject: TJSONObject);
var
  LPair: TPair<string, TValue>;
begin
  // ADVERTENCIA: Esto solo funcionará para tipos de TValue simples.
  // No se pueden serializar objetos complejos, punteros o records.
  ABlackboard.FLock.Enter;
  try
    for LPair in ABlackboard.FData do
    begin
      var
      LValue := LPair.Value;
      case LValue.Kind of
        tkInteger, tkInt64:
          AJSONObject.AddPair(LPair.Key, TJSONNumber.Create(LValue.AsInt64));
        tkFloat:
          AJSONObject.AddPair(LPair.Key, TJSONNumber.Create(LValue.AsExtended));
        tkString, tkUString:
          AJSONObject.AddPair(LPair.Key, TJSONString.Create(LValue.AsString));
        tkEnumeration:
          if LValue.TypeInfo = System.TypeInfo(Boolean) then
            AJSONObject.AddPair(LPair.Key, TJSONBool.Create(LValue.AsBoolean));
      end;
    end;
  finally
    ABlackboard.FLock.Leave;
  end;
end;

procedure DeserializeBlackboard(AJSONObject: TJSONObject; ABlackboard: TAIBlackboard);
var
  LPair: TJSONPair;
begin
  ABlackboard.Clear;
  for LPair in AJSONObject do
  begin
    var LJsonValue := LPair.JsonValue;
    if LJsonValue is TJSONString then
      ABlackboard.SetString(LPair.JsonString.Value, LJsonValue.Value)
    else if LJsonValue is TJSONNumber then
      // Simplificación: lo guardamos como float, se puede refinar
      ABlackboard.SetValue(LPair.JsonString.Value, StrToFloat(LJsonValue.Value))
    else if LJsonValue is TJSONBool then
      ABlackboard.SetBoolean(LPair.JsonString.Value, (LJsonValue as TJSONBool).AsBoolean);
  end;
end;

{ TAIBlackboard }

procedure TAIBlackboard.Clear;
begin
  FLock.Enter;
  try
    FData.Clear;
  finally
    FLock.Leave;
  end;
end;

constructor TAIBlackboard.Create;
begin
  inherited;
  FData := TDictionary<string, TValue>.Create;
  FLock := TCriticalSection.Create;
end;

destructor TAIBlackboard.Destroy;
begin
  FData.Free;
  FLock.Free;
  inherited;
end;

function TAIBlackboard.GetBoolean(const AKey: string; const ADefault: Boolean): Boolean;
var
  LValue: TValue;
begin
  if TryGetValue(AKey, LValue) and LValue.IsType<Boolean> then
    Result := LValue.AsBoolean
  else
    Result := ADefault;
end;

function TAIBlackboard.GetInteger(const AKey: string; const ADefault: Integer): Integer;
var
  LValue: TValue;
begin
  if TryGetValue(AKey, LValue) and LValue.IsType<Integer> then
    Result := LValue.AsInteger
  else
    Result := ADefault;
end;

function TAIBlackboard.GetString(const AKey, ADefault: string): string;
var
  LValue: TValue;
begin
  if TryGetValue(AKey, LValue) and LValue.IsType<string> then
    Result := LValue.AsString
  else
    Result := ADefault;
end;

procedure TAIBlackboard.SetBoolean(const AKey: string; AValue: Boolean);
begin
  SetValue(AKey, AValue);
end;

procedure TAIBlackboard.SetInteger(const AKey: string; AValue: Integer);
begin
  SetValue(AKey, AValue);
end;

procedure TAIBlackboard.SetString(const AKey, AValue: string);
begin
  SetValue(AKey, AValue);
end;

procedure TAIBlackboard.SetValue(const AKey: string; const AValue: TValue);
begin
  FLock.Enter;
  try
    FData.AddOrSetValue(AKey, AValue);
  finally
    FLock.Leave;
  end;
end;

function TAIBlackboard.TryGetValue(const AKey: string; out AValue: TValue): Boolean;
begin
  FLock.Enter;
  try
    Result := FData.TryGetValue(AKey, AValue);
  finally
    FLock.Leave;
  end;
end;

{ TAIAgents }

procedure TAIAgents.Abort;
begin
  FAbort := True;
end;

function TAIAgents.AddEdge(const AStartNodeName, AEndNodeName: string): TAIAgents;
var
  StartNode, EndNode: TAIAgentsNode;
  Link: TAIAgentsLink;
begin
  FCompiled := False;
  StartNode := FindNode(AStartNodeName);
  EndNode := FindNode(AEndNodeName);
  if not Assigned(StartNode) then
    raise Exception.CreateFmt('Edge creation failed: Start node "%s" not found.', [AStartNodeName]);
  if not Assigned(EndNode) then
    raise Exception.CreateFmt('Edge creation failed: End node "%s" not found.', [AEndNodeName]);

  Link := TAIAgentsLink.Create(Self);
  Link.Name := 'Link_' + AStartNodeName + '_to_' + AEndNodeName;
  Link.Graph := Self;
  Link.Mode := lmFanout;
  StartNode.Next := Link;
  Link.NextA := EndNode;
  Result := Self;
end;

function TAIAgents.AddNode(const AName: string; AExecuteProc: TAIAgentsNodeOnExecute): TAIAgents;
var
  Node: TAIAgentsNode;
begin
  FCompiled := False;
  if FindNode(AName) <> nil then
    raise Exception.CreateFmt('A node with the name "%s" already exists.', [AName]);

  Node := TAIAgentsNode.Create(Self);
  Node.Name := AName;
  Node.Graph := Self;
  Node.OnExecute := AExecuteProc;
  Result := Self;
end;

procedure TAIAgents.AddComponentToList(AComponent: TAIAgentsBase);
begin
  if AComponent is TAIAgentsNode then
  begin
    if FNodes.IndexOf(TAIAgentsNode(AComponent)) = -1 then
      FNodes.Add(TAIAgentsNode(AComponent));
  end
  else if AComponent is TAIAgentsLink then
  begin
    if FLinks.IndexOf(TAIAgentsLink(AComponent)) = -1 then
      FLinks.Add(TAIAgentsLink(AComponent));
  end;
end;

function TAIAgents.AddConditionalEdge(const AStartNodeName, AConditionalLinkName: string; AConditionalTargets: TDictionary<string, string>): TAIAgents;
var
  StartNode, TargetNode: TAIAgentsNode;
  Link: TAIAgentsLink;
  DecisionKey, TargetNodeName: string;
begin
  FCompiled := False;
  StartNode := FindNode(AStartNodeName);
  if not Assigned(StartNode) then
    raise Exception.CreateFmt('Conditional edge creation failed: Start node "%s" not found.', [AStartNodeName]);

  Link := TAIAgentsLink.Create(Self);
  Link.Name := AConditionalLinkName;
  Link.Graph := Self;
  Link.Mode := lmConditional;

  for DecisionKey in AConditionalTargets.Keys do
  begin
    TargetNodeName := AConditionalTargets.Items[DecisionKey];
    TargetNode := FindNode(TargetNodeName);
    if not Assigned(TargetNode) then
      raise Exception.CreateFmt('Conditional edge creation failed: Target node "%s" for decision "%s" not found.', [TargetNodeName, DecisionKey]);
    Link.AddConditionalTarget(DecisionKey, TargetNode);
  end;

  StartNode.Next := Link;
  Result := Self;
end;

procedure TAIAgents.ClearGraph;
begin
  FStartNode := nil;
  FEndNode := nil;
  FNodes.Clear;
  FLinks.Clear;
  for var i := ComponentCount - 1 downto 0 do
  begin
    if Components[i] is TAIAgentsBase then
      Components[i].Free;
  end;
  FCompiled := False;
end;

procedure TAIAgents.Compile;
var
  Node: TAIAgentsNode;
  Link: TAIAgentsLink;
  TargetNode: TAIAgentsNode;
  StartCount, EndCount: Integer;
begin
  if FCompiled then
    Exit;
  try
    FAbort := False;
    FBlackboard.Clear;

    if not Assigned(FStartNode) then
      raise Exception.Create('StartNode is not assigned.');
    if not Assigned(FEndNode) then
      raise Exception.Create('EndNode is not assigned.');

    StartCount := 0;
    EndCount := 0;
    for Node in FNodes do
    begin
      if Node = FStartNode then
        Inc(StartCount);
      if Node = FEndNode then
        Inc(EndCount);
      Node.Reset;
    end;
    if StartCount <> 1 then
      raise Exception.CreateFmt('Invalid number of StartNode references: %d (expected 1).', [StartCount]);
    if EndCount <> 1 then
      raise Exception.CreateFmt('Invalid number of EndNode references: %d (expected 1).', [EndCount]);

    for Link in FLinks do
    begin
      Link.Ready := False;
      Link.NoCycles := 0;
      if not Assigned(Link.FSourceNode) then
        raise Exception.CreateFmt('Link "%s" is not connected from any source node.', [Link.Name]);

      if Assigned(Link.NextA) then
        Link.NextA.FInEdges.Add(Link);
      if Assigned(Link.NextB) then
        Link.NextB.FInEdges.Add(Link);
      if Assigned(Link.NextC) then
        Link.NextC.FInEdges.Add(Link);
      if Assigned(Link.NextD) then
        Link.NextD.FInEdges.Add(Link);
      if Assigned(Link.NextNo) then
        Link.NextNo.FInEdges.Add(Link);

      if Assigned(Link.FConditionalTargets) then
      begin
        for TargetNode in Link.FConditionalTargets.Values do
          TargetNode.FInEdges.Add(Link);
      end;
    end;
    FCompiled := True;
  except
    on E: Exception do
    begin
      DoError(nil, nil, E);
      raise;
    end;
  end;
end;

constructor TAIAgents.Create(aOwner: TComponent);
begin
  inherited;
  FBlackboard := TAIBlackboard.Create;
  FNodes := TList<TAIAgentsNode>.Create;
  FLinks := TList<TAIAgentsLink>.Create;
  FActiveTasks := TList<ITask>.Create;
  FActiveTasksLock := TCriticalSection.Create;
  FCompiled := False;
  // --- NUEVO: Inicialización del Scheduler ---
  FMaxConcurrentTasks := 4;
  FTimeoutMs := 60000;
  FThreadPool := TThreadPool.Create;
  FThreadPool.SetMaxWorkerThreads(FMaxConcurrentTasks);
end;

destructor TAIAgents.Destroy;
begin
  FNodes.Free;
  FLinks.Free;
  FActiveTasks.Free;
  FActiveTasksLock.Free;
  FThreadPool.Free; // --- NUEVO: Liberación del Scheduler ---
  FBlackboard.Free;
  inherited;
end;

// ... (métodos DoConfirm, DoError, DoPrint, FindNode, etc. sin cambios) ...
procedure TAIAgents.DoError(Node: TAIAgentsNode; Link: TAIAgentsLink; E: Exception);
var
  LAbort: Boolean;
begin
  LAbort := True;
  if Assigned(FOnError) then
    FOnError(Self, Node, Link, E, LAbort);
  if LAbort then
    Abort;
end;

function TAIAgents.DoConfirm(Node: TAIAgentsNode; const AQuestion: string; Buttons: TMsgStates; var AResponse: string): TMsgState;
begin
  Result := msCancel;
  if Assigned(FOnConfirm) then
    FOnConfirm(Self, Node, AQuestion, Buttons, AResponse, Result)
  else
  begin
    DoError(Node, nil, Exception.Create('User confirmation required, but OnConfirm event is not assigned.'));
    Result := msAbort;
  end;
end;

procedure TAIAgents.DoPrint(Sender: TObject; Value: String);
begin
  if Assigned(FOnPrint) then
    FOnPrint(Sender, Value);
end;

procedure TAIAgents.DoPrintFromRef(Sender: TObject; Value: String);
begin
  if Assigned(FOnPrintRef) then
    FOnPrintRef(Sender, Value);
end;

function TAIAgents.FindNode(const AName: string): TAIAgentsNode;
var
  i: Integer;
begin
  Result := nil;
  for i := 0 to ComponentCount - 1 do
    if (Components[i] is TAIAgentsNode) and SameText(Components[i].Name, AName) then
    begin
      Result := TAIAgentsNode(Components[i]);
      Exit;
    end;
end;

// Asegúrate de tener estas unidades en la cláusula 'uses' de la implementation:
// System.JSON, System.JSON.Types, System.Rtti, System.TypInfo, uEngineRegistry

// ... (El helper DeserializeToolProperties y la clase TAgentHandlerRegistry se mantienen como antes) ...

// -----------------------------------------------------------------------------
// IMPLEMENTACIÓN FINAL DE TAIAgents.LoadFromStream
// -----------------------------------------------------------------------------
procedure TAIAgents.LoadFromStream(AStream: TStream);
var
  LRoot, LGraphJSON, LNodeJSON, LLinkJSON, LTargetsJSON: TJSONObject;
  LNodesArray, LLinksArray: TJSONArray;
  LReader: TStreamReader;
  LJsonValue: TJSONValue;
  LNode: TAIAgentsNode;
  LLink: TAIAgentsLink;
  LNodeMap: TDictionary<string, TAIAgentsNode>;
  LLinkMap: TDictionary<string, TAIAgentsLink>;
  LKey: string;
  LToolClass: TClass; // Variable para almacenar el tipo de clase de la herramienta
begin
  if not Assigned(AStream) or (AStream.Size = 0) then
    Exit;

  ClearGraph;

  LNodeMap := TDictionary<string, TAIAgentsNode>.Create;
  LLinkMap := TDictionary<string, TAIAgentsLink>.Create;
  LReader := TStreamReader.Create(AStream, TEncoding.UTF8);
  try
    LJsonValue := TJSONObject.ParseJSONValue(LReader.ReadToEnd);
    if not Assigned(LJsonValue) or not(LJsonValue is TJSONObject) then
      raise Exception.Create('Invalid JSON format: root is not an object.');
    LRoot := LJsonValue as TJSONObject;
    try
      // =======================================================================
      // PASADA 1: CREAR TODAS LAS INSTANCIAS DE NODOS Y ENLACES
      // =======================================================================

      // --- 1.A: Crear Nodos ---
      LNodesArray := LRoot.GetValue('nodes') as TJSONArray;
      if Assigned(LNodesArray) then
      begin
        for LJsonValue in LNodesArray do
        begin
          LNodeJSON := LJsonValue as TJSONObject;
          LKey := LNodeJSON.GetValue<string>('name', '');
          if LKey = '' then
            raise Exception.Create('Node found without a name in JSON.');
          if LNodeMap.ContainsKey(LKey) then
            raise Exception.CreateFmt('Duplicate node name found in JSON: "%s"', [LKey]);

          LNode := TAIAgentsNode.Create(Self);
          LNode.Name := LKey;
          LNode.Description := LNodeJSON.GetValue<string>('description', '');
          LNode.PromptName := LNodeJSON.GetValue<string>('promptName', '');

          var
          LJoinModeStr := LNodeJSON.GetValue<string>('joinMode', 'jmAny');
          LNode.JoinMode := TJoinMode(GetEnumValue(TypeInfo(TJoinMode), LJoinModeStr));

          // --- SECCIÓN CORREGIDA ---
          var
          LToolValue := LNodeJSON.GetValue('tool');
          if Assigned(LToolValue) and (LToolValue is TJSONObject) then
          begin
            var
            LToolDataObj := LToolValue as TJSONObject;
            var
            LToolClassName := LToolDataObj.GetValue<string>('className');
            if LToolClassName <> '' then
            begin
              // 1. Buscar el TIPO de clase en TU registro
              LToolClass := TEngineRegistry.Instance.FindToolClass(LToolClassName);

              // 2. Si se encontró, crear una instancia de esa clase
              if Assigned(LToolClass) and LToolClass.InheritsFrom(TAiToolBase) then
              begin
                // Creamos la instancia usando el NODO como propietario
                LNode.Tool := TAiToolBase(LToolClass).Create(LNode);

                // 3. Deserializar las propiedades en la nueva instancia
                var
                LPropertiesJSON := LToolDataObj.GetValue('properties') as TJSONObject;
                if Assigned(LPropertiesJSON) then
                  DeserializeToolProperties(LNode.Tool, LPropertiesJSON);
              end;
            end;
          end;
          // --- FIN DE LA CORRECCIÓN ---

          LNodeMap.Add(LKey, LNode);
        end;
      end;

      // --- 1.B: Crear Enlaces --- (Sin cambios)
      LLinksArray := LRoot.GetValue('links') as TJSONArray;
      if Assigned(LLinksArray) then
      begin
        for LJsonValue in LLinksArray do
        begin
          LLinkJSON := LJsonValue as TJSONObject;
          LKey := LLinkJSON.GetValue<string>('name', '');
          if LKey = '' then
            raise Exception.Create('Link found without a name in JSON.');
          if LLinkMap.ContainsKey(LKey) then
            raise Exception.CreateFmt('Duplicate link name found in JSON: "%s"', [LKey]);

          LLink := TAIAgentsLink.Create(Self);
          LLink.Name := LKey;
          LLink.Description := LLinkJSON.GetValue<string>('description', '');
          LLink.MaxCycles := LLinkJSON.GetValue<Integer>('maxCycles', 1);

          var
          LLinkModeStr := LLinkJSON.GetValue<string>('mode', 'lmFanout');
          LLink.Mode := TLinkMode(GetEnumValue(TypeInfo(TLinkMode), LLinkModeStr));

          if LLink.Mode = lmConditional then
            LLink.ConditionalKey := LLinkJSON.GetValue<string>('conditionalKey', 'next_route');

          if LLink.Mode = lmExpression then
          begin
            var
            LExpressionsJSON := LLinkJSON.GetValue('expressions') as TJSONObject;
            if Assigned(LExpressionsJSON) then
            begin
              LLink.ExpressionA := LExpressionsJSON.GetValue<string>('expressionA', '');
              LLink.ExpressionB := LExpressionsJSON.GetValue<string>('expressionB', '');
              LLink.ExpressionC := LExpressionsJSON.GetValue<string>('expressionC', '');
              LLink.ExpressionD := LExpressionsJSON.GetValue<string>('expressionD', '');
            end;
          end;

          LLinkMap.Add(LKey, LLink);
        end;
      end;

      // =======================================================================
      // PASADA 2: CONECTAR TODO (Sin cambios)
      // =======================================================================

      if Assigned(LNodesArray) then
      begin
        for LJsonValue in LNodesArray do
        begin
          LNodeJSON := LJsonValue as TJSONObject;
          LNode := LNodeMap[LNodeJSON.GetValue<string>('name')];
          var
          LNextLinkName := LNodeJSON.GetValue<string>('nextLink', '');
          if (LNextLinkName <> '') and LLinkMap.TryGetValue(LNextLinkName, LLink) then
            LNode.Next := LLink;
          var
          LHandlerName := LNodeJSON.GetValue<string>('onExecuteHandler', '');
          if LHandlerName <> '' then
            LNode.OnExecute := TAgentHandlerRegistry.Instance.FindNodeHandler(LHandlerName);
        end;
      end;

      if Assigned(LLinksArray) then
      begin
        for LJsonValue in LLinksArray do
        begin
          LLinkJSON := LJsonValue as TJSONObject;
          LLink := LLinkMap[LLinkJSON.GetValue<string>('name')];
          var
          LSourceNodeName := LLinkJSON.GetValue<string>('sourceNode', '');
          if (LSourceNodeName <> '') and LNodeMap.TryGetValue(LSourceNodeName, LNode) then
            LLink.FSourceNode := LNode;
          LTargetsJSON := LLinkJSON.GetValue('targets') as TJSONObject;
          if Assigned(LTargetsJSON) then
          begin
            if LNodeMap.TryGetValue(LTargetsJSON.GetValue<string>('nextA', ''), LNode) then
              LLink.NextA := LNode;
            if LNodeMap.TryGetValue(LTargetsJSON.GetValue<string>('nextB', ''), LNode) then
              LLink.NextB := LNode;
            if LNodeMap.TryGetValue(LTargetsJSON.GetValue<string>('nextC', ''), LNode) then
              LLink.NextC := LNode;
            if LNodeMap.TryGetValue(LTargetsJSON.GetValue<string>('nextD', ''), LNode) then
              LLink.NextD := LNode;
            if LNodeMap.TryGetValue(LTargetsJSON.GetValue<string>('nextNo', ''), LNode) then
              LLink.NextNo := LNode;
          end;
          var
          LCondTargetsJSON := LLinkJSON.GetValue('conditionalTargets') as TJSONObject;
          if Assigned(LCondTargetsJSON) then
          begin
            for var LPair in LCondTargetsJSON do
            begin
              var
              LTargetNodeName := LPair.JsonValue.Value;
              if LNodeMap.TryGetValue(LTargetNodeName, LNode) then
                LLink.AddConditionalTarget(LPair.JsonString.Value, LNode);
            end;
          end;
        end;
      end;

      // =======================================================================
      // PASO FINAL: CONFIGURAR GRAFO (Sin cambios)
      // =======================================================================
      LGraphJSON := LRoot.GetValue('graph') as TJSONObject;
      if Assigned(LGraphJSON) then
      begin
        Self.Description := LGraphJSON.GetValue<string>('description', '');
        Self.MaxConcurrentTasks := LGraphJSON.GetValue<Integer>('maxConcurrentTasks', 4);
        Self.TimeoutMs := LGraphJSON.GetValue<Cardinal>('timeoutMs', 60000);
        var
        LStartNodeName := LGraphJSON.GetValue<string>('startNode', '');
        if (LStartNodeName <> '') and LNodeMap.TryGetValue(LStartNodeName, LNode) then
          Self.StartNode := LNode;
        var
        LEndNodeName := LGraphJSON.GetValue<string>('endNode', '');
        if (LEndNodeName <> '') and LNodeMap.TryGetValue(LEndNodeName, LNode) then
          Self.EndNode := LNode;
      end;
      FCompiled := False;
    finally
      LRoot.Free;
    end;
  finally
    LReader.Free;
    LLinkMap.Free;
    LNodeMap.Free;
  end;
end;

procedure TAIAgents.LoadStateFromStream(AStream: TStream);
var
  LRoot, LStateObj, LBlackboardObj, LNodeStatesObj, LLinkStatesObj, LNodeStateObj, LJoinInputsObj: TJSONObject;
  LReader: TStreamReader;
  LJSONValue: TJSONValue;
  LNode: TAIAgentsNode;
  LLink: TAIAgentsLink;
  LPair: TJSONPair;
  LLinkMap: TDictionary<string, TAIAgentsLink>; // Mapa temporal para buscar links por nombre
begin
  if ComponentCount = 0 then
    raise Exception.Create('Cannot load state into an empty graph. Load the graph structure first.');

  // Crear mapa de links para una búsqueda rápida
  LLinkMap := TDictionary<string, TAIAgentsLink>.Create;
  for var i := 0 to ComponentCount - 1 do
    if Components[i] is TAIAgentsLink then
      LLinkMap.Add(Components[i].Name, TAIAgentsLink(Components[i]));

  LReader := TStreamReader.Create(AStream, TEncoding.UTF8);
  try
    LJSONValue := TJSONObject.ParseJSONValue(LReader.ReadToEnd);
    LRoot := LJSONValue as TJSONObject;
    try
      LStateObj := LRoot.GetValue('executionState') as TJSONObject;
      if not Assigned(LStateObj) then Exit;

      // 1. Restaurar el Blackboard
      LBlackboardObj := LStateObj.GetValue('blackboard') as TJSONObject;
      if Assigned(LBlackboardObj) then
        DeserializeBlackboard(LBlackboardObj, Self.Blackboard);

      // 2. Restaurar el estado de los nodos
      LNodeStatesObj := LStateObj.GetValue('nodeStates') as TJSONObject;
      if Assigned(LNodeStatesObj) then
      begin
        for LPair in LNodeStatesObj do
        begin
          LNode := FindNode(LPair.JsonString.Value);
          if Assigned(LNode) then
          begin
            LNodeStateObj := LPair.JsonValue as TJSONObject;
            LNode.Input := LNodeStateObj.GetValue<string>('input', '');
            LNode.Output := LNodeStateObj.GetValue<string>('output', '');

            // Restaurar entradas de Join
            LNode.FJoinInputs.Clear;
            LJoinInputsObj := LNodeStateObj.GetValue('joinInputs') as TJSONObject;
            if Assigned(LJoinInputsObj) then
            begin
              for var LJoinPair in LJoinInputsObj do
              begin
                if LLinkMap.TryGetValue(LJoinPair.JsonString.Value, LLink) then
                  LNode.FJoinInputs.Add(LLink, LJoinPair.JsonValue.Value);
              end;
            end;
          end;
        end;
      end;

      // 3. Restaurar el estado de los enlaces
      LLinkStatesObj := LStateObj.GetValue('linkStates') as TJSONObject;
      if Assigned(LLinkStatesObj) then
      begin
        for LPair in LLinkStatesObj do
        begin
          if LLinkMap.TryGetValue(LPair.JsonString.Value, LLink) then
          begin
            var LLinkStateObj := LPair.JsonValue as TJSONObject;
            LLink.FNoCycles := LLinkStateObj.GetValue<Integer>('noCycles', 0);
          end;
        end;
      end;

    finally
      LRoot.Free;
    end;
  finally
    LReader.Free;
    LLinkMap.Free;
  end;
end;
procedure TAIAgents.Notification(AComponent: TComponent; Operation: TOperation);
begin
  inherited;
  if (AComponent is TAIAgentsBase) then
  begin
    if Operation = opInsert then
      AddComponentToList(TAIAgentsBase(AComponent))
    else if Operation = opRemove then
      RemoveComponentFromList(TAIAgentsBase(AComponent));
  end;
end;

procedure TAIAgents.RemoveComponentFromList(AComponent: TAIAgentsBase);
begin
  if AComponent is TAIAgentsNode then
    FNodes.Remove(TAIAgentsNode(AComponent))
  else if AComponent is TAIAgentsLink then
    FLinks.Remove(TAIAgentsLink(AComponent));
end;

function TAIAgents.Run(Msg: String): ITask;
begin
  if Busy then
  begin
    DoError(nil, nil, Exception.Create('The Agents is already busy.'));
    Result := nil;
    Exit;
  end;

  Compile;

  FBusy := True;
  FAbort := False;

  FActiveTasksLock.Enter;
  try
    FActiveTasks.Clear;
  finally
    FActiveTasksLock.Leave;
  end;

  Result := TTask.Run(
    procedure
    var
      TasksToWaitOn: TArray<ITask>;
      WaitResult: Boolean;
      FinalStatus: string;
      FinalException: Exception;
      InitialInput: string;
    begin
      InitialInput := Msg; // Guardamos el input original
      FinalException := nil;
      FinalStatus := '';

      try
        try
          // --- DISPARAMOS EVENTO OnStart ---
          if Assigned(FOnStart) then
            TThread.Synchronize(nil,
              procedure
              begin
                FOnStart(Self, InitialInput);
              end);

          if FAbort then
          begin
            FinalStatus := 'Aborted'; // Puede ser abortado en el OnStart
            Exit;
          end;

          if Assigned(FStartNode) then
          begin
            FStartNode.Input := InitialInput;
            FStartNode.DoExecute(nil, nil);
          end;

          FActiveTasksLock.Enter;
          try
            TasksToWaitOn := FActiveTasks.ToArray;
          finally
            FActiveTasksLock.Leave;
          end;

          if Length(TasksToWaitOn) > 0 then
          begin
            WaitResult := TTask.WaitForAll(TasksToWaitOn, FTimeoutMs);

            if not WaitResult then
            begin
              // El tiempo de espera se agotó. Esto es un error.
              raise Exception.CreateFmt('Graph execution timed out after %d ms.', [FTimeoutMs]);
            end;
          end;

          // Si llegamos aquí sin errores y sin ser abortados, fue un éxito.
          if not FAbort then
            FinalStatus := 'Completed';

        except
          on E: Exception do
          begin
            Abort; // Aseguramos que todo se detenga
            FinalException := E; // Guardamos la excepción
            // Determinamos el status a partir del mensaje de error
            if E.Message.Contains('timed out') then
              FinalStatus := 'Timeout'
            else
              FinalStatus := 'Error';
            DoError(nil, nil, E); // Notificamos al evento OnError también
          end;
        end;
      finally
        // Si el estado no se ha establecido, es porque fue abortado.
        if FinalStatus = '' then
          FinalStatus := 'Aborted';

        Blackboard.SetString('Execution.Status', FinalStatus);

        if Assigned(FEndNode) then
        begin
          // El EndNode se puede usar para una última acción de limpieza
          FEndNode.ForceFinalExecute;
        end;

        FBusy := False;

        // --- DISPARAMOS EVENTO OnFinish ---
        if Assigned(FOnFinish) then
        begin
          var
          FinalOutput := '';
          if Assigned(FEndNode) then
            FinalOutput := FEndNode.Output;

          TThread.Synchronize(nil,
            procedure
            begin
              FOnFinish(Self, InitialInput, FinalOutput, FinalStatus, FinalException);
            end);
        end;
      end;
    end);
end;

// --- NUEVO: Setter para MaxConcurrentTasks ---
procedure TAIAgents.SetMaxConcurrentTasks(const Value: Integer);
var
  LNewValue: Integer;
begin
  LNewValue := Value;
  if LNewValue < 1 then
    LNewValue := 1;

  if FMaxConcurrentTasks <> LNewValue then
  begin
    FMaxConcurrentTasks := LNewValue;
    // --- CORREGIDO: TThreadPool ---
    // En lugar de recrear, simplemente ajustamos el pool existente.
    // Esto es más seguro si hay tareas en ejecución.
    if Assigned(FThreadPool) then
      FThreadPool.SetMaxWorkerThreads(FMaxConcurrentTasks);
  end;
end;

procedure TAIAgents.SaveStateToStream(AStream: TStream);
var
  LRoot, LStateObj, LBlackboardObj, LNodeStatesObj, LLinkStatesObj, LNodeStateObj, LJoinInputsObj: TJSONObject;
  LNode: TAIAgentsNode;
  LLink: TAIAgentsLink;
  LWriter: TStreamWriter;
  LPair: TPair<TAIAgentsLink, string>;
begin
  LRoot := TJSONObject.Create;
  try
    LStateObj := TJSONObject.Create;
    LRoot.AddPair('executionState', LStateObj);

    // 1. Guardar el Blackboard
    LBlackboardObj := TJSONObject.Create;
    SerializeBlackboard(Self.Blackboard, LBlackboardObj);
    LStateObj.AddPair('blackboard', LBlackboardObj);

    // 2. Guardar el estado de cada nodo
    LNodeStatesObj := TJSONObject.Create;
    for LNode in FNodes do
    begin
      LNodeStateObj := TJSONObject.Create;
      LNodeStateObj.AddPair('input', LNode.Input);
      LNodeStateObj.AddPair('output', LNode.Output);

      // Guardar las entradas pendientes en nodos de tipo Join
      LJoinInputsObj := TJSONObject.Create;
      if LNode.FJoinInputs.Count > 0 then
      begin
        for LPair in LNode.FJoinInputs do
        begin
          LJoinInputsObj.AddPair(LPair.Key.Name, LPair.Value);
        end;
      end;
      LNodeStateObj.AddPair('joinInputs', LJoinInputsObj);

      LNodeStatesObj.AddPair(LNode.Name, LNodeStateObj);
    end;
    LStateObj.AddPair('nodeStates', LNodeStatesObj);

    // 3. Guardar el estado de cada enlace
    LLinkStatesObj := TJSONObject.Create;
    for LLink in FLinks do
    begin
      var LLinkStateObj := TJSONObject.Create;
      LLinkStateObj.AddPair('noCycles', LLink.NoCycles);
      LLinkStatesObj.AddPair(LLink.Name, LLinkStateObj);
    end;
    LStateObj.AddPair('linkStates', LLinkStatesObj);

    // Escribir al Stream
    LWriter := TStreamWriter.Create(AStream, TEncoding.UTF8);
    try
      LWriter.Write(LRoot.ToString);
    finally
      LWriter.Free;
    end;

  finally
    LRoot.Free;
  end;
end;

procedure TAIAgents.SaveToStream(AStream: TStream);
var
  LRoot, LGraphObj, LNodeObj, LLinkObj, LTargetsObj, LExpressionsObj, LCondTargetsObj: TJSONObject;
  LNodesArray, LLinksArray: TJSONArray;
  LNode: TAIAgentsNode;
  LLink: TAIAgentsLink;
  LWriter: TStreamWriter;
  LPair: TPair<string, TAIAgentsNode>;
begin
  LRoot := TJSONObject.Create;
  try
    // 1. Sección "graph"
    LGraphObj := TJSONObject.Create;
    LGraphObj.AddPair('description', Self.Description);
    if Assigned(FStartNode) then
      LGraphObj.AddPair('startNode', FStartNode.Name)
    else
      LGraphObj.AddPair('startNode', TJSONNull.Create);

    if Assigned(FEndNode) then
      LGraphObj.AddPair('endNode', FEndNode.Name)
    else
      LGraphObj.AddPair('endNode', TJSONNull.Create);

    LGraphObj.AddPair('maxConcurrentTasks', TJSONNumber.Create(FMaxConcurrentTasks));
    LGraphObj.AddPair('timeoutMs', TJSONNumber.Create(FTimeoutMs));
    LRoot.AddPair('graph', LGraphObj);

    // 2. Sección "nodes"
    LNodesArray := TJSONArray.Create;
    for LNode in FNodes do
    begin
      LNodeObj := TJSONObject.Create;
      LNodeObj.AddPair('name', LNode.Name);
      LNodeObj.AddPair('description', LNode.Description);
      LNodeObj.AddPair('joinMode', GetEnumName(TypeInfo(TJoinMode), Ord(LNode.JoinMode)));
      LNodeObj.AddPair('promptName', LNode.PromptName);

      if Assigned(LNode.Tool) then
      begin
        // --- SECCIÓN MODIFICADA ---
        var
        LToolDataObj := TJSONObject.Create;
        LToolDataObj.AddPair('className', LNode.Tool.ClassName);
        LToolDataObj.AddPair('properties', SerializeToolProperties(LNode.Tool));
        LNodeObj.AddPair('tool', LToolDataObj);
        // --- FIN DE LA MODIFICACIÓN ---
      end
      else
      begin
        LNodeObj.AddPair('tool', TJSONNull.Create);
      end;

      // --- MANEJO DE EVENTOS (requiere lógica adicional) ---
      // Aquí guardarías un identificador del evento. Por ahora, un placeholder.
      if Assigned(LNode.OnExecute) then
        LNodeObj.AddPair('onExecuteHandler', 'HandlerFor_' + LNode.Name) // Placeholder
      else
        LNodeObj.AddPair('onExecuteHandler', TJSONNull.Create);

      if Assigned(LNode.Next) then
        LNodeObj.AddPair('nextLink', LNode.Next.Name)
      else
        LNodeObj.AddPair('nextLink', TJSONNull.Create);

      LNodesArray.Add(LNodeObj);
    end;
    LRoot.AddPair('nodes', LNodesArray);

    // 3. Sección "links"
    LLinksArray := TJSONArray.Create;
    for LLink in FLinks do
    begin
      LLinkObj := TJSONObject.Create;
      LLinkObj.AddPair('name', LLink.Name);
      LLinkObj.AddPair('description', LLink.Description);
      LLinkObj.AddPair('mode', GetEnumName(TypeInfo(TLinkMode), Ord(LLink.Mode)));
      LLinkObj.AddPair('maxCycles', LLink.MaxCycles);

      if Assigned(LLink.FSourceNode) then
        LLinkObj.AddPair('sourceNode', LLink.FSourceNode.Name)
      else
        LLinkObj.AddPair('sourceNode', TJSONNull.Create);

      // Guardar destinos en un sub-objeto "targets"
      LTargetsObj := TJSONObject.Create;

      if Assigned(LLink.NextA) then
        LTargetsObj.AddPair('nextA', LLink.NextA.Name)
      else
        LTargetsObj.AddPair('nextA', TJSONNull.Create);

      if Assigned(LLink.NextB) then
        LTargetsObj.AddPair('nextB', LLink.NextB.Name)
      else
        LTargetsObj.AddPair('nextB', TJSONNull.Create);

      if Assigned(LLink.NextC) then
        LTargetsObj.AddPair('nextC', LLink.NextC.Name)
      else
        LTargetsObj.AddPair('nextC', TJSONNull.Create);

      if Assigned(LLink.NextD) then
        LTargetsObj.AddPair('nextD', LLink.NextD.Name)
      else
        LTargetsObj.AddPair('nextD', TJSONNull.Create);

      if Assigned(LLink.NextNo) then
        LTargetsObj.AddPair('nextNo', LLink.NextNo.Name)
      else
        LTargetsObj.AddPair('nextNo', TJSONNull.Create);

      LLinkObj.AddPair('targets', LTargetsObj);

      // Guardar expresiones para el modo lmExpression
      if LLink.Mode = lmExpression then
      begin
        LExpressionsObj := TJSONObject.Create;
        LExpressionsObj.AddPair('expressionA', LLink.ExpressionA);
        LExpressionsObj.AddPair('expressionB', LLink.ExpressionB);
        LExpressionsObj.AddPair('expressionC', LLink.ExpressionC);
        LExpressionsObj.AddPair('expressionD', LLink.ExpressionD);
        LLinkObj.AddPair('expressions', LExpressionsObj);
      end;

      // Guardar destinos condicionales
      if LLink.Mode = lmConditional then
      begin
        LLinkObj.AddPair('conditionalKey', LLink.ConditionalKey);
        if Assigned(LLink.FConditionalTargets) then
        begin
          LCondTargetsObj := TJSONObject.Create;
          for LPair in LLink.FConditionalTargets do
          begin
            LCondTargetsObj.AddPair(LPair.Key, LPair.Value.Name);
          end;
          LLinkObj.AddPair('conditionalTargets', LCondTargetsObj);
        end;
      end;

      LLinksArray.Add(LLinkObj);
    end;
    LRoot.AddPair('links', LLinksArray);

    // 4. Escribir el JSON al Stream
    LWriter := TStreamWriter.Create(AStream, TEncoding.UTF8);
    try
      LWriter.Write(LRoot.ToString); // O LRoot.ToJSON para una versión más compacta
    finally
      LWriter.Free;
    end;

  finally
    LRoot.Free;
  end;
end;

procedure TAIAgents.SetDescription(const Value: String);
begin
  FDescription := Value;
end;

// ... (Setters restantes sin cambios) ...
procedure TAIAgents.SetEndNode(const Value: TAIAgentsNode);
begin
  if FEndNode <> Value then
  begin
    FEndNode := Value;
    FCompiled := False;
  end;
end;

function TAIAgents.SetEntryPoint(const ANodeName: string): TAIAgents;
begin
  Self.StartNode := FindNode(ANodeName);
  if not Assigned(Self.StartNode) then
    raise Exception.CreateFmt('Entry point node "%s" not found.', [ANodeName]);
  Result := Self;
end;

function TAIAgents.SetFinishPoint(const ANodeName: string): TAIAgents;
begin
  Self.EndNode := FindNode(ANodeName);
  if not Assigned(Self.EndNode) then
    raise Exception.CreateFmt('Finish point node "%s" not found.', [ANodeName]);
  Result := Self;
end;

procedure TAIAgents.SetOnConfirm(const Value: TAIAgentsOnConfirm);
begin
  FOnConfirm := Value;
end;

procedure TAIAgents.SetOnEnd(const Value: TAIAgentsOnEnd);
begin
  FOnEnd := Value;
end;

procedure TAIAgents.SetOnEnterNode(const Value: TAIAgentsOnEnterNode);
begin
  FOnEnterNode := Value;
end;

procedure TAIAgents.SetOnError(const Value: TAIAgentsOnError);
begin
  FOnError := Value;
end;

procedure TAIAgents.SetOnExitNode(const Value: TAIAgentsOnExitNode);
begin
  FOnExitNode := Value;
end;

procedure TAIAgents.SetOnFinish(const Value: TAIAgentsOnFinish);
begin
  FOnFinish := Value;
end;

procedure TAIAgents.SetOnPrint(const Value: TAIAgentsOnPrint);
begin
  if Assigned(Value) then
    FOnPrintRef := nil;
  FOnPrint := Value;
end;

procedure TAIAgents.SetOnPrintEvent(const APrintProc: TAgentPrintRef);
begin
  FOnPrintRef := APrintProc;
  if Assigned(FOnPrintRef) then
    FOnPrint := DoPrintFromRef
  else
    FOnPrint := nil;
end;

procedure TAIAgents.SetOnStart(const Value: TAIAgentsOnStart);
begin
  FOnStart := Value;
end;

procedure TAIAgents.SetStartNode(const Value: TAIAgentsNode);
begin
  if FStartNode <> Value then
  begin
    FStartNode := Value;
    FCompiled := False;
  end;
end;

{ TAIAgentsLink }

procedure TAIAgentsLink.AddConditionalTarget(const AKey: string; ANode: TAIAgentsNode);
begin
  if not Assigned(FConditionalTargets) then
    FConditionalTargets := TDictionary<string, TAIAgentsNode>.Create;
  FConditionalTargets.AddOrSetValue(AKey, ANode);
end;

procedure TAIAgentsLink.BuildManualTargets(const TargetsCSV: string; out Nodes: TList<TAIAgentsNode>);
// ... (sin cambios) ...
  function ResolveToken(const S: string): TAIAgentsNode;
  begin
    Result := nil;
    if SameText(S, 'A') then
      Exit(FNextA);
    if SameText(S, 'B') then
      Exit(FNextB);
    if SameText(S, 'C') then
      Exit(FNextC);
    if SameText(S, 'D') then
      Exit(FNextD);
    if Assigned(FGraph) then
      Result := FGraph.FindNode(S);
  end;

var
  Parts: TArray<string>;
  T: string;
  N: TAIAgentsNode;
begin
  Nodes := TList<TAIAgentsNode>.Create;
  if TargetsCSV.Trim = '' then
    Exit;
  Parts := TargetsCSV.Split([',']);
  for T in Parts do
  begin
    N := ResolveToken(Trim(T));
    if Assigned(N) then
      Nodes.Add(N);
  end;
end;

constructor TAIAgentsLink.Create(aOwner: TComponent);
begin
  inherited;
  // --- MODIFICADO: Constructor limpiado de duplicados ---
  FMaxCycles := 1;
  FMode := lmFanout;
  FConditionalKey := 'next_route';
  FManualTargetsKey := 'next_targets';
end;

procedure TAIAgentsLink.CreateAndQueueTask(ANodeToExecute, ASourceNode: TAIAgentsNode; ACurrentLink: TAIAgentsLink);
begin
  var
  LTask := TTask.Run(
    procedure
    begin
      // Esta clausura ahora captura los parámetros del método, que son estables y únicos.
      if (ACurrentLink.FGraph <> nil) and ACurrentLink.FGraph.FAbort then
        Exit;
      ANodeToExecute.DoExecute(ASourceNode, ACurrentLink);
    end, FGraph.FThreadPool);

  FGraph.FActiveTasksLock.Enter;
  try
    FGraph.FActiveTasks.Add(LTask);
  finally
    FGraph.FActiveTasksLock.Leave;
  end;
end;

destructor TAIAgentsLink.Destroy;
begin
  if Assigned(FConditionalTargets) then
    FConditionalTargets.Free;
  inherited;
end;

// --- MODIFICADO: Método de ejecución completamente refactorizado ---
procedure TAIAgentsLink.DoExecute(Sender: TAIAgentsNode);
var
  IsOk, Handled: Boolean;
  NodesToRun: TList<TAIAgentsNode>;
  Decision: string;
begin
  if (FGraph = nil) or FGraph.FAbort then
    Exit;

  // PASO 1: Ejecutar evento OnExecute para intervención manual
  Handled := False;
  IsOk := True;
  if Assigned(FOnExecute) then
  begin
    try
      FOnExecute(Sender, Self, IsOk, Handled);
    except
      on E: Exception do
      begin
        FGraph.DoError(Sender, Self, E);
        Exit;
      end;
    end;
  end;

  if Handled then
    Exit;

  // PASO 2: Evaluar el resultado de IsOk y manejar fallos/reintentos
  if not IsOk then
  begin
    Inc(FNoCycles);
    if FNoCycles >= FMaxCycles then
    begin
      var
      E := Exception.CreateFmt('Maximum retry cycles (%d) reached on link "%s" from node "%s". Aborting this path.', [FMaxCycles, Self.Name, Sender.Name]);
      FGraph.DoError(Sender, Self, E);
      Exit;
    end
    else
    begin
      if Assigned(FNextNo) then
      begin
        var
        LTask := TTask.Run(
          procedure
          begin
            if (FGraph <> nil) and not FGraph.FAbort then
              FNextNo.DoExecute(FSourceNode, Self);
          end, FGraph.FThreadPool);

        FGraph.FActiveTasksLock.Enter;
        try
          FGraph.FActiveTasks.Add(LTask);
        finally
          FGraph.FActiveTasksLock.Leave;
        end;
      end;
      Exit;
    end;
  end;

  // PASO 3: IsOk es TRUE. Construir la lista de nodos de destino según el modo.
  NodesToRun := nil;
  try
    NodesToRun := TList<TAIAgentsNode>.Create;
    case FMode of
      lmFanout:
        begin
          if Assigned(FNextA) then
            NodesToRun.Add(FNextA);
          if Assigned(FNextB) then
            NodesToRun.Add(FNextB);
          if Assigned(FNextC) then
            NodesToRun.Add(FNextC);
          if Assigned(FNextD) then
            NodesToRun.Add(FNextD);
        end;
      lmConditional:
        begin
          Decision := FGraph.Blackboard.GetString(IfThen(FConditionalKey <> '', FConditionalKey, 'next_route'));
          var
            TargetNode: TAIAgentsNode;
          if Assigned(FConditionalTargets) and FConditionalTargets.TryGetValue(Decision, TargetNode) and Assigned(TargetNode) then
            NodesToRun.Add(TargetNode)
          else if Assigned(FNextNo) then
            NodesToRun.Add(FNextNo);
        end;
      lmManual:
        begin
          Decision := FGraph.Blackboard.GetString(IfThen(FManualTargetsKey <> '', FManualTargetsKey, 'next_targets'));
          var
          ManualNodes := TList<TAIAgentsNode>.Create;
          try
            BuildManualTargets(Decision, ManualNodes);
            NodesToRun.AddRange(ManualNodes);
          finally
            ManualNodes.Free;
          end;
        end;
      lmExpression:
        begin
          var
          LBlackboardData := FGraph.Blackboard.FData;
          if Assigned(FNextA) and (FExpressionA <> '') and EvalCondition(FExpressionA, LBlackboardData) then
            NodesToRun.Add(FNextA)
          else if Assigned(FNextB) and (FExpressionB <> '') and EvalCondition(FExpressionB, LBlackboardData) then
            NodesToRun.Add(FNextB)
          else if Assigned(FNextC) and (FExpressionC <> '') and EvalCondition(FExpressionC, LBlackboardData) then
            NodesToRun.Add(FNextC)
          else if Assigned(FNextD) and (FExpressionD <> '') and EvalCondition(FExpressionD, LBlackboardData) then
            NodesToRun.Add(FNextD)
          else if Assigned(FNextNo) then
            NodesToRun.Add(FNextNo);
        end;
    end;
  except
    on E: Exception do
    begin
      if Assigned(NodesToRun) then
        NodesToRun.Free;
      FGraph.DoError(Sender, Self, E);
      Exit;
    end;
  end;

  // ---------------------------------------------------------------------------
  // PASO 4: Despachar la ejecución a los nodos de destino.
  // ---------------------------------------------------------------------------
  try
    if (NodesToRun = nil) or (NodesToRun.Count = 0) then
      Exit;

    if NodesToRun.Count = 1 then
    begin
      NodesToRun[0].DoExecute(FSourceNode, Self);
    end
    else // Fork paralelo con scheduler
    begin
      for var Node in NodesToRun do
      begin
        CreateAndQueueTask(Node, FSourceNode, Self);
      end;
    end;
  finally
    if Assigned(NodesToRun) then
      NodesToRun.Free;
  end;
end;

procedure TAIAgentsLink.Print(Value: String);
begin
  if Assigned(FGraph) then
    FGraph.DoPrint(Self, Value);
end;

// ... (Setters de TAIAgentsLink sin cambios) ...
procedure TAIAgentsLink.SetGraph(const Value: TAIAgents);
begin
  if Value <> FGraph then
  begin
    FGraph := Value;
    if Assigned(FGraph) then
      FGraph.FCompiled := False;
  end;
end;

procedure TAIAgentsLink.SetMaxCycles(const Value: Integer);
begin
  FMaxCycles := Value;
  if FMaxCycles < 1 then
    FMaxCycles := 1;
end;

procedure TAIAgentsLink.SetMode(const Value: TLinkMode);
begin
  if FMode <> Value then
  begin
    FMode := Value;
    if Assigned(FGraph) then
      FGraph.FCompiled := False;
  end;
end;

procedure TAIAgentsLink.SetNextA(const Value: TAIAgentsNode);
begin
  FNextA := Value;
end;

procedure TAIAgentsLink.SetNextB(const Value: TAIAgentsNode);
begin
  FNextB := Value;
end;

procedure TAIAgentsLink.SetNextC(const Value: TAIAgentsNode);
begin
  FNextC := Value;
end;

procedure TAIAgentsLink.SetNextD(const Value: TAIAgentsNode);
begin
  FNextD := Value;
end;

procedure TAIAgentsLink.SetNextNo(const Value: TAIAgentsNode);
begin
  FNextNo := Value;
end;

procedure TAIAgentsLink.SetOnExecute(const Value: TAIAgentsLinkOnExecute);
begin
  FOnExecute := Value;
end;

{ TAIAgentsNode }

constructor TAIAgentsNode.Create(aOwner: TComponent);
begin
  inherited;
  FInEdges := TList<TAIAgentsLink>.Create;
  FJoinLock := TCriticalSection.Create;
  // --- NUEVO: Inicializar diccionario de join ---
  FJoinInputs := TDictionary<TAIAgentsLink, string>.Create;
  FJoinMode := jmAny;
end;

destructor TAIAgentsNode.Destroy;
begin
  FInEdges.Free;
  FJoinLock.Free;
  FJoinInputs.Free; // --- NUEVO: Liberar diccionario de join ---
  inherited;
end;

procedure TAIAgentsNode.Reset;
begin
  FInEdges.Clear;
  FJoinInputs.Clear; // --- NUEVO: Limpiar diccionario de join ---
  Input := '';
  Output := '';
  FError := False;
  FMsgError := '';
end;

// --- MODIFICADO: Método DoExecute con lógica de JOIN corregida ---
procedure TAIAgentsNode.DoExecute(aBeforeNode: TAIAgentsNode; aLink: TAIAgentsLink);
var
  CanExecute: Boolean;
begin
  if (FGraph = nil) or FGraph.FAbort then
    Exit;

  if Assigned(FGraph.OnEnterNode) then
    TThread.Synchronize(nil,
      procedure
      begin
        FGraph.OnEnterNode(FGraph, Self);
      end);

  CanExecute := False;
  if FInEdges.Count > 1 then
  begin
    FJoinLock.Enter;
    try
      // Almacenar la entrada del camino que llega
      if (aBeforeNode <> nil) and (aLink <> nil) then
        FJoinInputs.AddOrSetValue(aLink, aBeforeNode.Output);

      case FJoinMode of
        jmAny:
          begin
            CanExecute := True;
            // Para jmAny, tomamos la entrada del primero que llega
            if aBeforeNode <> nil then
              Input := aBeforeNode.Output;
          end;
        jmAll:
          begin
            // Se ejecuta solo cuando han llegado todas las entradas
            if FJoinInputs.Count >= FInEdges.Count then
            begin
              CanExecute := True;
              // Consolidamos todas las entradas en un único string (ej. multilínea)
              var
              sb := TStringBuilder.Create;
              try
                for var Value in FJoinInputs.Values do
                  sb.AppendLine(Value);
                Input := sb.ToString;
              finally
                sb.Free;
              end;
            end;
          end;
      end;
    finally
      FJoinLock.Leave;
    end;
  end
  else
  begin
    CanExecute := True;
    if aBeforeNode <> nil then
      Input := aBeforeNode.Output; // Comportamiento normal para nodos sin join
  end;

  if not CanExecute then
    Exit;

  try
    if Assigned(FOnExecute) then
      FOnExecute(Self, aBeforeNode, aLink, Self.Input, FOutput)
    else if Assigned(FTool) then
      FTool.Run(Self, Self.Input, FOutput);

    if FOutput = '' then
      FOutput := Input;

    if Assigned(FGraph.OnExitNode) then
      TThread.Synchronize(nil,
        procedure
        begin
          FGraph.OnExitNode(FGraph, Self);
        end);

    if Assigned(Next) then
    begin
      Next.FSourceNode := Self;
      Next.DoExecute(Self);
    end;
  finally
    // --- NUEVO: Limpieza del estado del join después de la ejecución ---
    if CanExecute and (FInEdges.Count > 1) then
    begin
      FJoinLock.Enter;
      try
        if FJoinMode = jmAny then
          FJoinInputs.Clear; // Limpiamos para la siguiente ejecución
        if (FJoinMode = jmAll) and (FJoinInputs.Count >= FInEdges.Count) then
          FJoinInputs.Clear; // Reseteamos el estado del join
      finally
        FJoinLock.Leave;
      end;
    end;
  end;
end;

procedure TAIAgentsNode.ForceFinalExecute;
begin
  try
    if Assigned(FOnExecute) then
      FOnExecute(Self, nil, nil, Self.Input, FOutput);

    if Assigned(FGraph.OnEnd) then
      TThread.Synchronize(nil,
        procedure
        begin
          FGraph.OnEnd(Self, Output);
        end);
  except
    on E: Exception do
      FGraph.DoError(Self, nil, E);
  end;
end;

procedure TAIAgentsNode.Print(Value: String);
begin
  if Assigned(FGraph) then
    FGraph.DoPrint(Self, Value);
end;

function TAIAgentsNode.RequestConfirmation(const AQuestion: string; Buttons: TMsgStates; var AResponse: string): TMsgState;
begin
  if Assigned(FGraph) then
    Result := FGraph.DoConfirm(Self, AQuestion, Buttons, AResponse)
  else
    Result := msAbort;
end;

function TAIAgentsNode.RequestInput(const ACaption, APrompt: string; var AValue: string): Boolean;
var
  Response: string;
  ModalResult: TMsgState;
begin
  Response := AValue;
  ModalResult := RequestConfirmation(ACaption + '|' + APrompt, [msOK, msCancel], Response);
  if ModalResult = msOK then
  begin
    AValue := Response;
    Result := True;
  end
  else
    Result := False;
end;

// ... (Setters de TAIAgentsNode sin cambios) ...
procedure TAIAgentsNode.SetGraph(const Value: TAIAgents);
begin
  if Value <> FGraph then
  begin
    if Assigned(FGraph) then
      FGraph.RemoveComponentFromList(Self);
    FGraph := Value;
    if Assigned(FGraph) then
    begin
      FGraph.AddComponentToList(Self);
      FGraph.FCompiled := False;
    end;
  end;
end;

procedure TAIAgentsNode.SetInput(const Value: String);
begin
  FInput := Value;
end;

procedure TAIAgentsNode.SetJoinMode(const Value: TJoinMode);
begin
  FJoinMode := Value;
end;

procedure TAIAgentsNode.SetNext(const Value: TAIAgentsLink);
begin
  if Value <> FNext then
  begin
    if Assigned(FNext) then
      FNext.FSourceNode := nil;
    FNext := Value;
    if Assigned(FNext) then
      FNext.FSourceNode := Self;
    if Assigned(Graph) then
      Graph.FCompiled := False;
  end;
end;

procedure TAIAgentsNode.SetOnExecute(const Value: TAIAgentsNodeOnExecute);
begin
  FOnExecute := Value;
end;

procedure TAIAgentsNode.SetOutput(const Value: String);
begin
  FOutput := Value;
end;

procedure TAIAgentsNode.SetPromptName(const Value: String);
begin
  FPromptName := Value;
end;

procedure TAIAgentsNode.SetTool(const Value: TAiToolBase);
begin
  FTool := Value;
end;

{ TAIAgentsBase }
procedure TAIAgentsBase.SetDescription(const Value: String);
begin
  FDescription := Value;
end;

{ TAiToolBase }
procedure TAiToolBase.Run(ANode: TAIAgentsNode; const AInput: string; var AOutput: string);
begin
  Execute(ANode, AInput, AOutput);
end;

procedure TAiToolBase.SetDescription(const Value: String);
begin
  FDescription := Value;
end;

{ TAiSampleTool }
procedure TAiAgentsToolSample.Execute(ANode: TAIAgentsNode; const AInput: string; var AOutput: string);
begin
  ANode.Print(Format('TAiSampleTool: Executing with input "%s"', [AInput]));
  AOutput := 'Output from TAiSampleTool: ' + AInput;
end;

end.

unit uMakerAi.Agents.EngineRegistry;

interface

uses
  System.SysUtils, System.Classes, System.JSON, System.Generics.Collections, System.Variants, System.TypInfo,
  // Dependencias del "Motor"
  uMakerAi.Agents, uMakerAi.Attributes;

type
  // Este es el "contrato" de datos que el Diseñador recibirá.
  // Es un simple registro, no contiene clases ni lógica compleja.
  TToolBlueprint = record
    ToolClassName: string;
    DisplayName: string;
    Description: string;
    Category: string;
    Schema: TJSONObject;
  end;

  // El Singleton que actúa como nuestra "caja negra".
  TEngineRegistry = class
  private
  class var
    FInstance: TEngineRegistry;
    FRegisteredTools: TDictionary<string, TClass>;
    constructor Create;
  public
    destructor Destroy; override;
    class property Instance: TEngineRegistry read FInstance;

    procedure RegisterTool(ToolClass: TClass);
    function FindToolClass(const AToolClassName: string): TClass;
    function GetToolBlueprints: TArray<TToolBlueprint>;
  end;

  TAgentHandlerRegistry = class
  private
  class var
    FInstance: TAgentHandlerRegistry;
    FNodeHandlers: TDictionary<string, TAIAgentsNodeOnExecute>;
    FLinkHandlers: TDictionary<string, TAIAgentsLinkOnExecute>;
    constructor Create;
  public
    destructor Destroy; override;
    class property Instance: TAgentHandlerRegistry read FInstance;

    procedure RegisterNodeHandler(const AName: string; AHandler: TAIAgentsNodeOnExecute);
    procedure RegisterLinkHandler(const AName: string; AHandler: TAIAgentsLinkOnExecute);
    function FindNodeHandler(const AName: string): TAIAgentsNodeOnExecute;
    function FindLinkHandler(const AName: string): TAIAgentsLinkOnExecute;
  end;

implementation

uses System.Rtti;

// Helper interno para generar los esquemas JSON de los parámetros.
type
  TSchemaGen_Internal = class
  private
    class function DelphiTypeToJSONType(APropType: TRttiType): string;
    class function DelphiTypeToJSONFormat(APropType: TRttiType): string;
  public
    class function GenerateSchemaFor(AClass: TClass): TJSONObject;
  end;

  { TEngineRegistry }

constructor TEngineRegistry.Create;
begin
  inherited;
  FRegisteredTools := TDictionary<string, TClass>.Create;
end;

destructor TEngineRegistry.Destroy;
begin
  FRegisteredTools.Free;
  inherited;
end;

function TEngineRegistry.FindToolClass(const AToolClassName: string): TClass;
begin
  FRegisteredTools.TryGetValue(AToolClassName, Result);
end;

procedure TEngineRegistry.RegisterTool(ToolClass: TClass);
begin
  if not ToolClass.InheritsFrom(TAiToolBase) then
    raise Exception.CreateFmt('Cannot register class "%s" because it does not inherit from TAiToolBase.', [ToolClass.ClassName]);

  FRegisteredTools.Add(ToolClass.ClassName, ToolClass);
end;

function TEngineRegistry.GetToolBlueprints: TArray<TToolBlueprint>;
var
  ToolClass: TClass;
  LContext: TRttiContext;
  LRttiType: TRttiType;
  ClassToolAttr: TToolAttribute; // Variable para el atributo de CLASE
  i: Integer;
begin
  SetLength(Result, FRegisteredTools.Count);
  i := 0;
  LContext := TRttiContext.Create;
  try
    for ToolClass in FRegisteredTools.Values do
    begin
      LRttiType := LContext.GetType(ToolClass);
      ClassToolAttr := nil;

      // --- CORRECCIÓN APLICADA AQUÍ ---
      // Buscar el atributo [TToolAttribute] en la clase
      for var Attr in LRttiType.GetAttributes do
      begin
        // Buscamos el tipo de atributo correcto para la clase
        if Attr is TToolAttribute then
        begin
          ClassToolAttr := Attr as TToolAttribute;
          Break;
        end;
      end;

      Result[i].ToolClassName := ToolClass.ClassName;

      if Assigned(ClassToolAttr) then
      begin
        // Si encontramos el atributo, usamos sus valores
        Result[i].DisplayName := ClassToolAttr.Name;
        Result[i].Description := ClassToolAttr.Description; // <-- ¡Ahora se leerá correctamente!
        Result[i].Category := ClassToolAttr.Category;
      end
      else
      begin
        // Plan B: si la herramienta no tiene el atributo, usar valores por defecto
        Result[i].DisplayName := ToolClass.ClassName.Substring(1);
        Result[i].Description := 'No description provided.';
        Result[i].Category := 'Uncategorized';
      end;

      // La generación del esquema para los parámetros no cambia, ya que
      // busca TToolParameterAttribute y eso ya era correcto.
      Result[i].Schema := TSchemaGen_Internal.GenerateSchemaFor(ToolClass);

      Inc(i);
    end;
  finally
    LContext.Free;
  end;
end;

{ TSchemaGen_Internal }

class function TSchemaGen_Internal.GenerateSchemaFor(AClass: TClass): TJSONObject;
var
  LContext: TRttiContext;
  LRttiType: TRttiType;
  LProp: TRttiProperty;
  ParamAttr: TToolParameterAttribute; // Busca el atributo de PARÁMETRO
  LProperties, LPropSchema: TJSONObject;
  JsonType: string;
begin
  Result := TJSONObject.Create;
  LProperties := TJSONObject.Create;
  Result.AddPair('type', 'object');
  Result.AddPair('title', AClass.ClassName.Substring(1));
  Result.AddPair('properties', LProperties);

  LContext := TRttiContext.Create;
  try
    LRttiType := LContext.GetType(AClass);
    for LProp in LRttiType.GetProperties do
    begin
      ParamAttr := nil;
      for var Attr in LProp.GetAttributes do
        if Attr is TToolParameterAttribute then
        begin
          ParamAttr := Attr as TToolParameterAttribute;
          Break;
        end;

      if Assigned(ParamAttr) then
      begin
        LPropSchema := TJSONObject.Create;
        LPropSchema.AddPair('title', ParamAttr.DisplayName);
        LPropSchema.AddPair('description', ParamAttr.Hint);
        JsonType := DelphiTypeToJSONType(LProp.PropertyType);
        LPropSchema.AddPair('type', JsonType);

        var
        LFormat := DelphiTypeToJSONFormat(LProp.PropertyType);
        if not LFormat.IsEmpty then
          LPropSchema.AddPair('format', LFormat);

        if not ParamAttr.DefaultValue.IsEmpty then
        begin
          var
          PropTypeKind := LProp.PropertyType.TypeKind;
          if (PropTypeKind = tkInteger) or (PropTypeKind = tkInt64) then
            LPropSchema.AddPair('default', TJSONNumber.Create(StrToIntDef(ParamAttr.DefaultValue, 0)))
          else if PropTypeKind = tkFloat then
            LPropSchema.AddPair('default', TJSONNumber.Create(StrToFloatDef(ParamAttr.DefaultValue, 0.0)))
          else if PropTypeKind = tkEnumeration then
            if LProp.PropertyType.Handle = TypeInfo(Boolean) then
              LPropSchema.AddPair('default', TJSONBool.Create(SameText(ParamAttr.DefaultValue, 'True')))
            else
              LPropSchema.AddPair('default', TJSONString.Create(ParamAttr.DefaultValue))
          else
            LPropSchema.AddPair('default', TJSONString.Create(ParamAttr.DefaultValue));
        end;

        if (LProp.PropertyType.TypeKind = tkEnumeration) and (LProp.PropertyType.Handle <> TypeInfo(Boolean)) then
        begin
          var
          LEnumArray := TJSONArray.Create;
          var
          RttiEnum := LProp.PropertyType as TRttiEnumerationType;
          for var EnumName in RttiEnum.GetNames do
            LEnumArray.Add(EnumName);
          LPropSchema.AddPair('enum', LEnumArray);
        end;

        LProperties.AddPair(LProp.Name, LPropSchema);
      end;
    end;
  finally
    LContext.Free;
  end;
end;

class function TSchemaGen_Internal.DelphiTypeToJSONType(APropType: TRttiType): string;
begin
  if not Assigned(APropType) then
    Exit('string');
  case APropType.TypeKind of
    tkInteger, tkInt64:
      Result := 'integer';
    tkFloat:
      Result := 'number';
    tkEnumeration:
      if APropType.Handle = TypeInfo(Boolean) then
        Result := 'boolean'
      else
        Result := 'string';
    tkString, tkUString, tkChar, tkWChar, tkLString, tkWString:
      Result := 'string';
    tkClass:
      if APropType.Handle = TypeInfo(TDateTime) then
        Result := 'string'
      else if APropType.Handle = TypeInfo(TDate) then
        Result := 'string'
      else if APropType.Handle = TypeInfo(TTime) then
        Result := 'string'
      else
        Result := 'string';
  else
    Result := 'string';
  end;
end;

class function TSchemaGen_Internal.DelphiTypeToJSONFormat(APropType: TRttiType): string;
begin
  Result := '';
  if not Assigned(APropType) then
    Exit;
  if APropType.Handle = TypeInfo(TDateTime) then
    Result := 'date-time'
  else if APropType.Handle = TypeInfo(TDate) then
    Result := 'date'
  else if APropType.Handle = TypeInfo(TTime) then
    Result := 'time';
end;

{ TAgentHandlerRegistry }

constructor TAgentHandlerRegistry.Create;
begin
  inherited;
  FNodeHandlers := TDictionary<string, TAIAgentsNodeOnExecute>.Create;
  FLinkHandlers := TDictionary<string, TAIAgentsLinkOnExecute>.Create;
end;

destructor TAgentHandlerRegistry.Destroy;
begin
  FNodeHandlers.Free;
  FLinkHandlers.Free;
  inherited;
end;

function TAgentHandlerRegistry.FindNodeHandler(const AName: string): TAIAgentsNodeOnExecute;
begin
  FNodeHandlers.TryGetValue(AName, Result);
end;

function TAgentHandlerRegistry.FindLinkHandler(const AName: string): TAIAgentsLinkOnExecute;
begin
  FLinkHandlers.TryGetValue(AName, Result);
end;

procedure TAgentHandlerRegistry.RegisterNodeHandler(const AName: string; AHandler: TAIAgentsNodeOnExecute);
begin
  FNodeHandlers.AddOrSetValue(AName, AHandler);
end;

procedure TAgentHandlerRegistry.RegisterLinkHandler(const AName: string; AHandler: TAIAgentsLinkOnExecute);
begin
  FLinkHandlers.AddOrSetValue(AName, AHandler);
end;

initialization

TEngineRegistry.FInstance := TEngineRegistry.Create;
TAgentHandlerRegistry.FInstance := TAgentHandlerRegistry.Create;

finalization

TEngineRegistry.FInstance.Free;
TAgentHandlerRegistry.FInstance.Free;

end.

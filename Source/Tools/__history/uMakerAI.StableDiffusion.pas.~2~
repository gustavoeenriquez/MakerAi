unit uMakerAI.StableDiffusion;

interface

uses
  System.SysUtils, System.Classes, System.Generics.Collections, System.Types,
  System.Net.HttpClient, System.Net.URLClient, Rest.Json, System.Json, System.Threading, // System.Threading still useful for TThread.Queue
  System.Net.HttpClientComponent;

type
  // Evento para reportar progreso
  TSDProgressEvent = procedure(Sender: TObject; Progress: Double; CurrentStep, TotalSteps: Integer; Base64ImagePreview: string) of object;
  // Evento para reportar errores
  TSDErrorEvent = procedure(Sender: TObject; const ErrorMessage: string; E: Exception) of object;

  // Forward declaration for the custom thread class
  TStableDiffusion = Class;

  // Custom Thread for Progress Monitoring
  TProgressMonitorThread = class(TThread)
  private
    FStableDiffusionComponent: TStableDiffusion; // Reference to the owning component
    FInterval: Integer; // Polling interval in milliseconds
  protected
    procedure Execute; override;
  public
    constructor Create(AStableDiffusion: TStableDiffusion; AInterval: Integer = 1000); reintroduce;
  end;

  TStableDiffusion = class(TComponent)
  private
    FHttpClient: TNetHTTPClient;
    FUrl: String; // Base URL for the entire API (e.g., http://127.0.0.1:7860)
    FResponseTimeout: Integer;
    FSendTimeout: Integer;
    FIsGenerating: Boolean; // Indica si hay una generación en curso
    FLastError: string;

    FOnProgress: TSDProgressEvent;
    FOnError: TSDErrorEvent;

    // --- Progress Monitoring with TThread ---
    FProgressMonitorThread: TProgressMonitorThread; // Our custom thread instance
    // No longer needed: FProgressCancellationTokenSource: TTaskCancellationTokenSource;
    // --- New Properties from TSDImageGenerationOptions ---
    FSamplerName: string;
    FSteps: Integer;
    FWidth: Integer;
    FHeight: Integer;
    FCFGScale: Double;
    FSeed: Integer;
    FBatchSize: Integer;
    FNIters: Integer;
    FDenoisingStrength: Double; // Note: This will be a default for img2img, inpainting
    FEnableHiresFix: Boolean;
    FHiresScale: Double;
    FHiresUpscaler: string;
    FHiresSecondPassSteps: Integer;
    FHiresResizeX: Integer;
    FHiresResizeY: Integer;
    FRefinerCheckpoint: string;
    FRefinerSwitchAt: Double;

    // --- Setters for Properties ---
    procedure SetUrl(const Value: String);
    procedure SetResponseTimeout(const Value: Integer);
    procedure SetSendTimeout(const Value: Integer);
    procedure SetOnProgress(const Value: TSDProgressEvent);
    procedure SetOnError(const Value: TSDErrorEvent);

    // Setters for Image Generation Options
    procedure SetSamplerName(const Value: string);
    procedure SetSteps(const Value: Integer);
    procedure SetWidth(const Value: Integer);
    procedure SetHeight(const Value: Integer);
    procedure SetCFGScale(const Value: Double);
    procedure SetSeed(const Value: Integer);
    procedure SetBatchSize(const Value: Integer);
    procedure SetNIters(const Value: Integer);
    procedure SetDenoisingStrength(const Value: Double);
    procedure SetEnableHiresFix(const Value: Boolean);
    procedure SetHiresScale(const Value: Double);
    procedure SetHiresUpscaler(const Value: string);
    procedure SetHiresSecondPassSteps(const Value: Integer);
    procedure SetHiresResizeX(const Value: Integer);
    procedure SetHiresResizeY(const Value: Integer);
    procedure SetRefinerCheckpoint(const Value: string);
    procedure SetRefinerSwitchAt(const Value: Double);

    // Helpers internos para construir y enviar peticiones JSON
    function GetSDAPIBaseURL: string; // Helper to get the base URL for sdapi/v1/
    function GetRembgBaseURL: string; // Helper to get the base URL for rembg

    procedure StartProgressMonitoringThread;
    procedure StopProgressMonitoringThread; // Called by the component to stop the thread

    // Changed SendPostRequest/SendGetRequest to be protected/public if TProgressMonitorThread needs to call them.
    // Making them public for TProgressMonitorThread to access.
  protected
    property ResponseTimeout: Integer read FResponseTimeout write SetResponseTimeout;
    property SendTimeout: Integer read FSendTimeout write SetSendTimeout;
    property LastError: string read FLastError; // Solo lectura, para obtener el último error

    // These need to be accessible by TProgressMonitorThread
    function SendPostRequest(const BaseURL, Endpoint: string; const RequestData: TJSONObject; out ResponseContent: string): Boolean;
    function SendGetRequest(const BaseURL, Endpoint: string; out ResponseContent: string): Boolean;
    procedure SetCommonImageGenerationParams(Params: TJSONObject); // No longer takes Options record
    procedure DoError(const ErrorMessage: string; E: Exception = nil);

  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    // Métodos para interactuar con la API de Stable Diffusion

    // Generación de Imagen (Text-to-Image)
    function TxtToImg(const PromptPositivo, PromptNegativo: string; out Base64Imagen: string): Boolean;

    // Transformación de Imagen (Image-to-Image)
    // DenoisingStrength is now a property, but can be overridden for specific calls
    function ImgToImg(const Base64Input: string; const PromptPositivo, PromptNegativo: string;
      const ADenoisingStrength: Double; out Base64Output: string): Boolean; // -1.0 indicates use property value

    // Restauración de Imagen (GFPGAN/CodeFormer)
    function RestoreImage(const Base64ImageIn: string; out Base64ImageOut: string): Boolean;

    // Inpainting
    // DenoisingStrength is now a property, but can be overridden for specific calls
    function InpaintImage(const Base64ImageIn: string; const Base64Mask: string; const PromptPositivo, PromptNegativo: string;
      const ADenoisingStrength: Double; InpaintingFill, MaskBlur: Integer; out Base64ImageOut: string): Boolean; // -1.0 indicates use property value

    // Descripción de Imagen (CLIP Interrogator)
    function DescribeImage(const Base64ImageIn: string): string;

    // Remoción de Fondo
    function RemoveBackground(const Model: string; const Base64Input: string; out Base64Output: string): Boolean;

    // Gestión de Modelos
    function GetModels: TStringList;
    function ChangeModel(const ModelName: string): Boolean;
    function GetCurrentModel: string;

    property IsGenerating: Boolean read FIsGenerating; // Indica si se está generando algo (observado por el thread de progreso)

  Published
    Property Url: String read FUrl write SetUrl; // Base URL

    // --- Propiedades de configuración de generación de imagen ---
    property SamplerName: string read FSamplerName write SetSamplerName;
    property Steps: Integer read FSteps write SetSteps;
    property Width: Integer read FWidth write SetWidth;
    property Height: Integer read FHeight write SetHeight;
    property CFGScale: Double read FCFGScale write SetCFGScale;
    property Seed: Integer read FSeed write SetSeed;
    property BatchSize: Integer read FBatchSize write SetBatchSize;
    property NIters: Integer read FNIters write SetNIters;
    property DenoisingStrength: Double read FDenoisingStrength write SetDenoisingStrength;
    property EnableHiresFix: Boolean read FEnableHiresFix write SetEnableHiresFix;
    property HiresScale: Double read FHiresScale write SetHiresScale;
    property HiresUpscaler: string read FHiresUpscaler write SetHiresUpscaler;
    property HiresSecondPassSteps: Integer read FHiresSecondPassSteps write SetHiresSecondPassSteps;
    property HiresResizeX: Integer read FHiresResizeX write SetHiresResizeX;
    property HiresResizeY: Integer read FHiresResizeY write SetHiresResizeY;
    property RefinerCheckpoint: string read FRefinerCheckpoint write SetRefinerCheckpoint;
    property RefinerSwitchAt: Double read FRefinerSwitchAt write SetRefinerSwitchAt;

    // Eventos
    property OnProgress: TSDProgressEvent read FOnProgress write SetOnProgress;
    property OnError: TSDErrorEvent read FOnError write SetOnError;
  end;

procedure Register;

implementation

procedure Register;
begin
  RegisterComponents('MakerAI', [TStableDiffusion]);
end;

const
  DEFAULT_BASE_URL = 'http://127.0.0.1:7860';

{ TProgressMonitorThread }

constructor TProgressMonitorThread.Create(AStableDiffusion: TStableDiffusion; AInterval: Integer);
begin
  inherited Create(True); // Create suspended
  FStableDiffusionComponent := AStableDiffusion;
  FInterval := AInterval;
  FreeOnTerminate := True; // Thread will free itself when it finishes
end;

procedure TProgressMonitorThread.Execute;
var
  ResponseContent: string;
  JsonObject: TJSONObject;
  Progress: Double;
  SamplingStep, SamplingSteps: Integer;
  Base64Image: String;
begin
  // Set a name for easier debugging
  NameThreadForDebugging('SDProgressMonitorThread');

  while not Terminated do
  begin
    // Check if the generation process is still ongoing in the main component
    if not FStableDiffusionComponent.IsGenerating then
    begin
      // If FIsGenerating is false, it means the main generation process has completed
      // or encountered an error. The progress thread can now stop.
      Break;
    end;

    try
      if FStableDiffusionComponent.SendGetRequest(FStableDiffusionComponent.GetSDAPIBaseURL, 'progress', ResponseContent) then
      begin
        JsonObject := TJSONObject(TJSONObject.ParseJSONValue(ResponseContent));
        try
          Progress := JsonObject.GetValue<Double>('progress'); // Progress is 0.0 to 1.0
          SamplingStep := JsonObject.GetValue<TJSONObject>('state').GetValue<Integer>('sampling_step');
          SamplingSteps := JsonObject.GetValue<TJSONObject>('state').GetValue<Integer>('sampling_steps');

          Base64Image := ''; // Clear for cases where no image is available yet
          JsonObject.TryGetValue<String>('current_image', Base64Image);

          // Synchronize event back to main thread
          if Assigned(FStableDiffusionComponent.FOnProgress) then
          begin
            TThread.Queue(nil,
              procedure
              begin
                FStableDiffusionComponent.FOnProgress(FStableDiffusionComponent, Progress * 100, SamplingStep, SamplingSteps, Base64Image);
              end);
          end;

          // Check for completion based on API response
          // A progress of ~1.0 or sampling steps matching total steps indicates completion
          if (Progress >= 0.999) or ((SamplingSteps > 0) and (SamplingStep >= SamplingSteps)) then
          begin
            FStableDiffusionComponent.FIsGenerating := False; // Mark generation as complete
            Break; // Exit the loop
          end;
        finally
          FreeAndNil(JsonObject); // Ensure JSON object is freed
        end;
      end
      else
      begin
        // If SendGetRequest fails (e.g., server not responding), stop monitoring
        FStableDiffusionComponent.DoError('No se pudo obtener el progreso de Stable Diffusion. Monitoreo detenido.', nil);
        FStableDiffusionComponent.FIsGenerating := False; // Mark as not generating due to API error
        Break;
      end;
    except
      on E: Exception do
      begin
        FStableDiffusionComponent.DoError(Format('Error durante el monitoreo de progreso: %s', [E.Message]), E);
        FStableDiffusionComponent.FIsGenerating := False; // Mark as not generating due to unexpected exception
        Break;
      end;
    end;

    // Wait for the next poll, respecting termination request
    Sleep(FInterval);
  end;

  // When the thread exits its loop, ensure FIsGenerating is false
  FStableDiffusionComponent.FIsGenerating := False;
end;


{ TStableDiffusion }

constructor TStableDiffusion.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FUrl := DEFAULT_BASE_URL;

  FHttpClient := TNetHTTPClient.Create(Self);
{$IF CompilerVersion >= 35}
  FHttpClient.SynchronizeEvents := False; // Importante para permitir que los callbacks se ejecuten en hilos (o que TTask no los bloquee)
{$ENDIF}

  FResponseTimeout := 8 * 60000; // 8 minutos por defecto
  FSendTimeout := 8 * 60000; // 8 minutos por defecto
  FHttpClient.ResponseTimeout := FResponseTimeout;
{$IF CompilerVersion >= 35}
  FHttpClient.SendTimeout := FSendTimeout;
{$ENDIF}


  FIsGenerating := False;
  FProgressMonitorThread := nil; // No thread instance initially

  // Inicializar nuevas propiedades de generación de imagen con valores por defecto
  FSamplerName := 'DPM++ 2M SDE';
  FSteps := 20;
  FWidth := 1024;
  FHeight := 1024;
  FCFGScale := 7.0; // Un valor más común para cfg_scale
  FSeed := -1;
  FBatchSize := 1;
  FNIters := 1;
  FDenoisingStrength := 0.75; // Por defecto para img2img/inpainting
  FEnableHiresFix := False;
  FHiresScale := 2;
  FHiresUpscaler := 'Latent';
  FHiresSecondPassSteps := 0;
  FHiresResizeX := 0; // 0 indica que use el doble del original si enable_hr es true
  FHiresResizeY := 0;
  FRefinerCheckpoint := '';
  FRefinerSwitchAt := 0.8;
end;

destructor TStableDiffusion.Destroy;
begin
  StopProgressMonitoringThread; // Asegurar que el thread se cancele y finalice antes de liberar FHttpClient
  FHttpClient.Free;
  inherited;
end;

procedure TStableDiffusion.DoError(const ErrorMessage: string; E: Exception);
begin
  FLastError := ErrorMessage;
  if Assigned(FOnError) then
    TThread.Queue(nil, // Use TThread.Queue to ensure event fires on main thread
      procedure
      begin
        FOnError(Self, ErrorMessage, E);
      end);
end;

// --- URL Management Helpers ---

function TStableDiffusion.GetSDAPIBaseURL: string;
begin
  Result := FUrl + '/sdapi/v1/';
end;

function TStableDiffusion.GetRembgBaseURL: string;
begin
  Result := FUrl + '/rembg';
end;

function TStableDiffusion.SendPostRequest(const BaseURL, Endpoint: string; const RequestData: TJSONObject; out ResponseContent: string): Boolean;
var
  St: TStringStream;
  Res: IHTTPResponse;
  FullURL: string;
begin
  Result := False;
  St := TStringStream.Create(RequestData.ToString, TEncoding.UTF8);
  try
    FHttpClient.ContentType := 'application/json';
    FHttpClient.Accept := '*/*'; // Aceptar cualquier tipo de respuesta

    FullURL := BaseURL + Endpoint;
    Res := FHttpClient.Post(FullURL, St);

    if Res.StatusCode = 200 then
    begin
      ResponseContent := Res.ContentAsString;
      Result := True;
    end
    else
    begin
      DoError(Format('Error en la petición POST a %s: %d - %s', [FullURL, Res.StatusCode, Res.ContentAsString]), nil);
    end;
  finally
    St.Free;
  end;
end;

function TStableDiffusion.SendGetRequest(const BaseURL, Endpoint: string; out ResponseContent: string): Boolean;
var
  Res: IHTTPResponse;
  FullURL: string;
begin
  Result := False;
  try
    FHttpClient.Accept := '*/*'; // Aceptar cualquier tipo de respuesta
    FullURL := BaseURL + Endpoint;
    Res := FHttpClient.Get(FullURL);

    if Res.StatusCode = 200 then
    begin
      ResponseContent := Res.ContentAsString;
      Result := True;
    end
    else
    begin
      DoError(Format('Error en la petición GET a %s: %d - %s', [FullURL, Res.StatusCode, Res.ContentAsString]), nil);
    end;
  finally
    // No hay streams que liberar aquí, el HttpClient se encarga del response
  end;
end;

procedure TStableDiffusion.SetCommonImageGenerationParams(Params: TJSONObject);
begin
  Params.AddPair('sampler_name', FSamplerName);
  Params.AddPair('steps', TJSONNumber.Create(FSteps));
  Params.AddPair('width', TJSONNumber.Create(FWidth));
  Params.AddPair('height', TJSONNumber.Create(FHeight));
  Params.AddPair('cfg_scale', TJSONNumber.Create(FCFGScale));
  Params.AddPair('seed', TJSONNumber.Create(FSeed));
  Params.AddPair('batch_size', TJSONNumber.Create(FBatchSize));
  Params.AddPair('n_iter', TJSONNumber.Create(FNIters));

  // Parámetros de Hires fix
  if FEnableHiresFix then
  begin
    Params.AddPair('enable_hr', TJSONBool.Create(True));
    Params.AddPair('hr_scale', TJSONNumber.Create(FHiresScale));
    Params.AddPair('hr_upscaler', FHiresUpscaler);
    if FHiresSecondPassSteps > 0 then
      Params.AddPair('hr_second_pass_steps', TJSONNumber.Create(FHiresSecondPassSteps));
    if FHiresResizeX > 0 then
      Params.AddPair('hr_resize_x', TJSONNumber.Create(FHiresResizeX));
    if FHiresResizeY > 0 then
      Params.AddPair('hr_resize_y', TJSONNumber.Create(FHiresResizeY));
  end;

  // Parámetros de Refiner
  if not FRefinerCheckpoint.IsEmpty then
  begin
    Params.AddPair('refiner_checkpoint', FRefinerCheckpoint);
    Params.AddPair('refiner_switch_at', TJSONNumber.Create(FRefinerSwitchAt));
  end;
end;

function TStableDiffusion.TxtToImg(const PromptPositivo, PromptNegativo: string; out Base64Imagen: string): Boolean;
var
  Params: TJSONObject;
  ResponseContent: string;
  Resultado: TJSONObject;
  ImageArray: TJSONArray;
begin
  Result := False;
  FIsGenerating := True;
  Base64Imagen := '';
  StartProgressMonitoringThread; // Iniciar monitoreo de progreso

  Params := TJSONObject.Create;
  try
    Params.AddPair('prompt', PromptPositivo);
    Params.AddPair('negative_prompt', PromptNegativo);
    SetCommonImageGenerationParams(Params); // Usa las propiedades del componente

    if SendPostRequest(GetSDAPIBaseURL, 'txt2img', Params, ResponseContent) then
    begin
      Resultado := TJSONObject(TJSONObject.ParseJSONValue(ResponseContent));
      try
        ImageArray := Resultado.GetValue<TJSONArray>('images');
        if (ImageArray <> nil) and (ImageArray.Count > 0) then
        begin
          Base64Imagen := ImageArray.Items[0].Value;
          Result := True;
        end
        else
          DoError('No se encontraron imágenes en la respuesta de txt2img.');
      finally
        Resultado.Free;
      end;
    end;
  finally
    Params.Free;
    // FIsGenerating is typically set to False by the progress thread upon completion or error.
    // However, if an immediate error occurs before the thread can even start or poll,
    // ensure FIsGenerating is reset.
    if not Result then FIsGenerating := False;
  end;
end;

function TStableDiffusion.ImgToImg(const Base64Input: string; const PromptPositivo, PromptNegativo: string;
  const ADenoisingStrength: Double; out Base64Output: string): Boolean;
var
  Params: TJSONObject;
  ResponseContent: string;
  Resultado: TJSONObject;
  ImageArray: TJSONArray;
  DenoisingToUse: Double;
begin
  Result := False;
  FIsGenerating := True;
  Base64Output := '';
  StartProgressMonitoringThread; // Iniciar monitoreo de progreso

  Params := TJSONObject.Create;
  try
    Params.AddPair('prompt', PromptPositivo);
    Params.AddPair('negative_prompt', PromptNegativo);
    Params.AddPair('init_images', TJSONArray.Create(TJSONString.Create(Base64Input)));

    SetCommonImageGenerationParams(Params); // Usa las propiedades del componente

    // Override DenoisingStrength if a specific value is provided
    DenoisingToUse := FDenoisingStrength;
    if ADenoisingStrength >= 0.0 then // Using -1.0 as sentinel for "use property default"
      DenoisingToUse := ADenoisingStrength;
    Params.AddPair('denoising_strength', TJSONNumber.Create(DenoisingToUse));

    if SendPostRequest(GetSDAPIBaseURL, 'img2img', Params, ResponseContent) then
    begin
      Resultado := TJSONObject(TJSONObject.ParseJSONValue(ResponseContent));
      try
        ImageArray := Resultado.GetValue<TJSONArray>('images');
        if (ImageArray <> nil) and (ImageArray.Count > 0) then
        begin
          Base64Output := ImageArray.Items[0].Value;
          Result := True;
        end
        else
          DoError('No se encontraron imágenes en la respuesta de img2img.');
      finally
        Resultado.Free;
      end;
    end;
  finally
    Params.Free;
    if not Result then FIsGenerating := False;
  end;
end;

function TStableDiffusion.RestoreImage(const Base64ImageIn: string; out Base64ImageOut: string): Boolean;
var
  Params: TJSONObject;
  ResponseContent: string;
  Resultado: TJSONObject;
begin
  Result := False;
  Base64ImageOut := '';

  Params := TJSONObject.Create;
  try
    Params.AddPair('image', Base64ImageIn);
    Params.AddPair('gfpgan_visibility', TJSONNumber.Create(1.0));
    Params.AddPair('codeformer_visibility', TJSONNumber.Create(0.0));
    Params.AddPair('codeformer_weight', TJSONNumber.Create(0.5));

    // RestoreImage is usually fast, no need for progress monitoring
    if SendPostRequest(GetSDAPIBaseURL, 'extra-single-image', Params, ResponseContent) then
    begin
      Resultado := TJSONObject(TJSONObject.ParseJSONValue(ResponseContent));
      try
        Base64ImageOut := Resultado.GetValue<string>('image');
        Result := True;
      finally
        Resultado.Free;
      end;
    end;
  finally
    Params.Free;
  end;
end;

function TStableDiffusion.InpaintImage(const Base64ImageIn: string; const Base64Mask: string; const PromptPositivo, PromptNegativo: string;
  const ADenoisingStrength: Double; InpaintingFill, MaskBlur: Integer; out Base64ImageOut: string): Boolean;
var
  Params: TJSONObject;
  ResponseContent: string;
  Resultado: TJSONObject;
  ImageArray: TJSONArray;
  DenoisingToUse: Double;
begin
  Result := False;
  FIsGenerating := True;
  Base64ImageOut := '';
  StartProgressMonitoringThread; // Iniciar monitoreo de progreso

  Params := TJSONObject.Create;
  try
    Params.AddPair('init_images', TJSONArray.Create(TJSONString.Create(Base64ImageIn)));
    Params.AddPair('mask', Base64Mask);
    Params.AddPair('prompt', PromptPositivo);
    Params.AddPair('negative_prompt', PromptNegativo);

    SetCommonImageGenerationParams(Params); // Usa las propiedades del componente

    // Override DenoisingStrength if a specific value is provided
    DenoisingToUse := FDenoisingStrength;
    if ADenoisingStrength >= 0.0 then // Using -1.0 as sentinel for "use property default"
      DenoisingToUse := ADenoisingStrength;
    Params.AddPair('denoising_strength', TJSONNumber.Create(DenoisingToUse));

    // Opciones específicas de inpainting
    Params.AddPair('inpainting_fill', TJSONNumber.Create(InpaintingFill)); // 0=original, 1=fill, 2=latent noise, 3=latent nothing
    Params.AddPair('mask_blur', TJSONNumber.Create(MaskBlur));

    if SendPostRequest(GetSDAPIBaseURL, 'img2img', Params, ResponseContent) then // Inpainting usa el endpoint img2img
    begin
      Resultado := TJSONObject(TJSONObject.ParseJSONValue(ResponseContent));
      try
        ImageArray := Resultado.GetValue<TJSONArray>('images');
        if (ImageArray <> nil) and (ImageArray.Count > 0) then
        begin
          Base64ImageOut := ImageArray.Items[0].Value;
          Result := True;
        end
        else
          DoError('No se encontraron imágenes en la respuesta de inpainting.');
      finally
        Resultado.Free;
      end;
    end;
  finally
    Params.Free;
    if not Result then FIsGenerating := False;
  end;
end;

function TStableDiffusion.DescribeImage(const Base64ImageIn: string): string;
var
  Params: TJSONObject;
  ResponseContent: string;
  Resultado: TJSONObject;
begin
  Result := '';

  Params := TJSONObject.Create;
  try
    Params.AddPair('image', Base64ImageIn);
    Params.AddPair('model', 'clip'); // 'clip' o 'deepdanbooru'

    // DescribeImage is usually fast, no need for progress monitoring
    if SendPostRequest(GetSDAPIBaseURL, 'interrogate', Params, ResponseContent) then
    begin
      Resultado := TJSONObject(TJSONObject.ParseJSONValue(ResponseContent));
      try
        Result := Resultado.GetValue<string>('caption');
      finally
        Resultado.Free;
      end;
    end;
  finally
    Params.Free;
  end;
end;

function TStableDiffusion.RemoveBackground(const Model: string; const Base64Input: string; out Base64Output: string): Boolean;
var
  Params: TJSONObject;
  ResponseContent: string;
  Resultado: TJSONObject;
begin
  Result := False;
  Base64Output := '';

  Params := TJSONObject.Create;
  try
    Params.AddPair('input_image', Base64Input);
    Params.AddPair('model', Model);

    // Rembg usa un endpoint diferente, no /sdapi/v1/
    if SendPostRequest(GetRembgBaseURL, '', Params, ResponseContent) then // Endpoint vacío porque la URL ya es directa
    begin
      Resultado := TJSONObject.ParseJSONValue(ResponseContent) as TJSONObject;
      if Assigned(Resultado) and Resultado.TryGetValue('image', Base64Output) then
        Result := True;
    end;
  finally
    FreeAndNil(Resultado); // Liberar el objeto JSON si fue creado
    Params.Free;
  end;
end;

function TStableDiffusion.GetModels: TStringList;
var
  ResponseContent: string;
  JsonArray: TJSONArray;
  JsonObject: TJSONObject;
  I: Integer;
begin
  Result := TStringList.Create;
  if SendGetRequest(GetSDAPIBaseURL, 'sd-models', ResponseContent) then
  begin
    JsonArray := TJSONArray(TJSONObject.ParseJSONValue(ResponseContent));
    try
      for I := 0 to JsonArray.Count - 1 do
      begin
        JsonObject := JsonArray.Items[I] as TJSONObject;
        Result.Add(JsonObject.GetValue('model_name').Value);
      end;
    finally
      JsonArray.Free;
    end;
  end;
end;

function TStableDiffusion.ChangeModel(const ModelName: string): Boolean;
var
  Params: TJSONObject;
  ResponseContent: string;
begin
  Result := False;

  Params := TJSONObject.Create;
  try
    Params.AddPair('sd_model_checkpoint', ModelName);
    Result := SendPostRequest(GetSDAPIBaseURL, 'options', Params, ResponseContent); // No se necesita la respuesta en este caso
  finally
    Params.Free;
  end;
end;

function TStableDiffusion.GetCurrentModel: string;
var
  ResponseContent: string;
  JsonObject: TJSONObject;
  I: Integer;
begin
  Result := 'Desconocido';
  if SendGetRequest(GetSDAPIBaseURL, 'options', ResponseContent) then
  begin
    JsonObject := TJSONObject(TJSONObject.ParseJSONValue(ResponseContent));
    try
      if JsonObject.TryGetValue('sd_model_checkpoint', Result) then
      begin
        // Eliminar la extensión .safetensors si existe
        I := Pos('.safetensors', Result);
        If I > 0 then
          Result := Trim(Copy(Result, 1, I - 1)); // Copy es 1-indexed
      end;
    finally
      JsonObject.Free;
    end;
  end;
end;

// --- TThread Progress Monitoring Implementation ---

procedure TStableDiffusion.StartProgressMonitoringThread;
begin
  // Only start a new thread if one is not already running or finished
  if not Assigned(FProgressMonitorThread) or FProgressMonitorThread.Finished then
  begin
    FProgressMonitorThread := TProgressMonitorThread.Create(Self);
    FProgressMonitorThread.Resume; // Start the thread (or use .Start in newer Delphis)
  end;
end;

procedure TStableDiffusion.StopProgressMonitoringThread;
begin
  if Assigned(FProgressMonitorThread) then
  begin
    if not FProgressMonitorThread.Finished then
    begin
      FProgressMonitorThread.Terminate; // Request the thread to stop
      FProgressMonitorThread.WaitFor; // Wait for the thread to finish cleanly
    end;
    FProgressMonitorThread := nil; // Clear the reference (FreeOnTerminate will handle actual freeing)
  end;
end;


// --- Property Setters ---

procedure TStableDiffusion.SetUrl(const Value: String);
begin
  FUrl := Value;
end;

procedure TStableDiffusion.SetResponseTimeout(const Value: Integer);
begin
  FResponseTimeout := Value;
  FHttpClient.ResponseTimeout := Value;
end;

procedure TStableDiffusion.SetSendTimeout(const Value: Integer);
begin
  FSendTimeout := Value;
  FHttpClient.SendTimeout := Value;
end;

procedure TStableDiffusion.SetOnProgress(const Value: TSDProgressEvent);
begin
  FOnProgress := Value;
end;

procedure TStableDiffusion.SetOnError(const Value: TSDErrorEvent);
begin
  FOnError := Value;
end;

procedure TStableDiffusion.SetSamplerName(const Value: string);
begin
  FSamplerName := Value;
end;

procedure TStableDiffusion.SetSteps(const Value: Integer);
begin
  FSteps := Value;
end;

procedure TStableDiffusion.SetWidth(const Value: Integer);
begin
  FWidth := Value;
end;

procedure TStableDiffusion.SetHeight(const Value: Integer);
begin
  FHeight := Value;
end;

procedure TStableDiffusion.SetCFGScale(const Value: Double);
begin
  FCFGScale := Value;
end;

procedure TStableDiffusion.SetSeed(const Value: Integer);
begin
  FSeed := Value;
end;

procedure TStableDiffusion.SetBatchSize(const Value: Integer);
begin
  FBatchSize := Value;
end;

procedure TStableDiffusion.SetNIters(const Value: Integer);
begin
  FNIters := Value;
end;

procedure TStableDiffusion.SetDenoisingStrength(const Value: Double);
begin
  FDenoisingStrength := Value;
end;

procedure TStableDiffusion.SetEnableHiresFix(const Value: Boolean);
begin
  FEnableHiresFix := Value;
end;

procedure TStableDiffusion.SetHiresScale(const Value: Double);
begin
  FHiresScale := Value;
end;

procedure TStableDiffusion.SetHiresUpscaler(const Value: string);
begin
  FHiresUpscaler := Value;
end;

procedure TStableDiffusion.SetHiresSecondPassSteps(const Value: Integer);
begin
  FHiresSecondPassSteps := Value;
end;

procedure TStableDiffusion.SetHiresResizeX(const Value: Integer);
begin
  FHiresResizeX := Value;
end;

procedure TStableDiffusion.SetHiresResizeY(const Value: Integer);
begin
  FHiresResizeY := Value;
end;

procedure TStableDiffusion.SetRefinerCheckpoint(const Value: string);
begin
  FRefinerCheckpoint := Value;
end;

procedure TStableDiffusion.SetRefinerSwitchAt(const Value: Double);
begin
  FRefinerSwitchAt := Value;
end;

end.

unit uWinSoundMonitor;

interface

uses
  System.SysUtils, System.Types, System.Classes, System.Variants,
  System.IOUtils, System.SyncObjs, System.Math, System.Permissions,

{$IFDEF MSWINDOWS}
  Winapi.Windows, Winapi.MMSystem;
{$ENDIF}
{$IFDEF ANDROID}
  AndroidApi.JNI.Media, AndroidApi.JNIBridge, AndroidApi.Helpers,
  FMX.Helpers.Android, AndroidApi.JNI.JavaTypes;
{$ENDIF}

const
  DEFAULT_SAMPLE_RATE = 44100;
  DEFAULT_CHANNELS = 1;
  DEFAULT_BITS_PER_SAMPLE = 16;
  DEFAULT_BUFFER_DURATION_MS = 100;
  DEFAULT_CALIBRATION_DURATION_SEC = 3;
  DEFAULT_SILENCE_DURATION_MS = 1000;

type
  TRiffHeader = packed record
    ChunkID: array[0..3] of AnsiChar;
    ChunkSize: LongWord;
    Format: array[0..3] of AnsiChar;
  end;

  TFmtChunk = packed record
    Subchunk1ID: array[0..3] of AnsiChar;
    Subchunk1Size: LongWord;
    AudioFormat: SmallInt;
    NumChannels: SmallInt;
    SampleRate: LongWord;
    ByteRate: LongWord;
    BlockAlign: SmallInt;
    BitsPerSample: SmallInt;
  end;

  TDataChunk = packed record
    Subchunk2ID: array[0..3] of AnsiChar;
    Subchunk2Size: LongWord;
  end;

  TMonitorState = (msIdle, msRequestingPermission, msCalibrating, msMonitoring, msError);
  TAudioMonitorOnChange = procedure(Sender: TObject; aState: Boolean; aStream: TMemoryStream) of object;
  // MODIFICADO: El evento OnCalibrated ahora informa de ambos umbrales
  TAudioMonitorOnCalibrated = procedure(Sender: TObject; const aNoiseLevel, aSensitivity, aStopSensitivity: Integer) of object;
  TAudioMonitorOnUpdate = procedure(Sender: TObject; const aSoundLevel: Int64) of object;
  TAudioMonitorOnError = procedure(Sender: TObject; const ErrorMessage: string) of object;

  TAudioMonitor = class(TObject)
  private
    FCS: TCriticalSection;
    FBuffer: TBytes;
    FArrBuf: TArray<Boolean>;
    FFileStream: TMemoryStream;
    FIsSpeaking: Boolean;
    FActive: Boolean;
    FMonitorState: TMonitorState;
    FSoundLevel: Int64;

    // Umbrales de sensibilidad
    FSensitivity: Integer;             // Umbral ALTO para empezar a hablar
    FStopSensitivity: Integer;         // NUEVO: Umbral BAJO para dejar de hablar

    // Lógica de Calibración
    FCalibrationSamples: Integer;
    FCalibrationAccumulator: Int64;
    FCalibrationDurationSec: Integer;

    // Configuración
    FSilenceDuration: Integer;
    FSampleRate: Integer;
    FChannels: Integer;
    FBitsPerSample: Integer;
    FBufferSize: Integer;
    // NUEVO: Multiplicadores para ajustar la sensibilidad
    FSensitivityMultiplier: Double;
    FStopSensitivityMultiplier: Double;

    // Eventos
    FOnChangeState: TAudioMonitorOnChange;
    FOnCalibrated: TAudioMonitorOnCalibrated;
    FOnUpdate: TAudioMonitorOnUpdate;
    FOnError: TAudioMonitorOnError;

{$IFDEF MSWINDOWS}
    FhWaveIn: HWAVEIN;
    FWaveHdr: TWaveHdr;
{$ENDIF}
{$IFDEF ANDROID}
    FAudioRecord: JAudioRecord;
    FCaptureThread: TThread;
{$ENDIF}

    procedure SetActive(const Value: Boolean);
    procedure SetSilenceDuration(const Value: Integer);
    procedure DoError(const aMessage: string);

  protected
    procedure CalcSilencio;
    procedure DoChangeState(aIsSpeaking: Boolean);
    procedure ConvertPCMToWAV(PCMStream, WAVStream: TMemoryStream);
    procedure ProcessAudioBuffer(const aBuffer: TBytes; aSize: Integer);

{$IFDEF MSWINDOWS}
    procedure StartCaptureAudioWindows;
    procedure StopCaptureAudioWindows;
{$ENDIF}
{$IFDEF ANDROID}
    procedure StartCaptureAudioAndroid;
    procedure StopCaptureAudioAndroid;
    procedure AndroidCaptureLoop;
    procedure HandlePermissionRequest(Sender: TObject; const APermissions: TArray<string>; const AGrantResults: TArray<TPermissionStatus>);
{$ENDIF}
  public
    constructor Create(const aSampleRate: Integer = DEFAULT_SAMPLE_RATE;
                       const aChannels: Integer = DEFAULT_CHANNELS;
                       const aBitsPerSample: Integer = DEFAULT_BITS_PER_SAMPLE);
    destructor Destroy; override;

    procedure Start;
    procedure Stop;

    property Active: Boolean read FActive write SetActive;
    property SoundLevel: Int64 read FSoundLevel;
    property IsSpeaking: Boolean read FIsSpeaking;
    property Sensitivity: Integer read FSensitivity;
    property StopSensitivity: Integer read FStopSensitivity; // NUEVO
    property State: TMonitorState read FMonitorState;
    property SilenceDuration: Integer read FSilenceDuration write SetSilenceDuration;

    // NUEVO: Propiedades para configurar los multiplicadores
    property SensitivityMultiplier: Double read FSensitivityMultiplier write FSensitivityMultiplier;
    property StopSensitivityMultiplier: Double read FStopSensitivityMultiplier write FStopSensitivityMultiplier;

    property OnChangeState: TAudioMonitorOnChange read FOnChangeState write FOnChangeState;
    property OnCalibrated: TAudioMonitorOnCalibrated read FOnCalibrated write FOnCalibrated;
    property OnUpdate: TAudioMonitorOnUpdate read FOnUpdate write FOnUpdate;
    property OnError: TAudioMonitorOnError read FOnError write FOnError;
  end;

implementation

{$IFDEF MSWINDOWS}
procedure AudioCallback(hWaveIn: HWAVEIN; uMsg: UINT; dwInstance, dwParam1, dwParam2: DWORD_PTR); stdcall;
var
  Monitor: TAudioMonitor;
  WaveHdr: PWAVEHDR;
begin
  if uMsg = WIM_DATA then
  begin
    Monitor := TAudioMonitor(dwInstance);
    WaveHdr := PWAVEHDR(dwParam1);
    if Assigned(Monitor) and Assigned(WaveHdr) then
    begin
      Monitor.ProcessAudioBuffer(Monitor.FBuffer, WaveHdr^.dwBytesRecorded);
      if Monitor.Active then
        waveInAddBuffer(hWaveIn, @Monitor.FWaveHdr, SizeOf(TWaveHdr));
    end;
  end;
end;
{$ENDIF}

{ TAudioMonitor }

constructor TAudioMonitor.Create(const aSampleRate: Integer; const aChannels: Integer; const aBitsPerSample: Integer);
begin
  inherited Create;
  FCS := TCriticalSection.Create;

  FSampleRate := aSampleRate;
  FChannels := aChannels;
  FBitsPerSample := aBitsPerSample;
  FBufferSize := (FSampleRate * FChannels * (FBitsPerSample div 8) * DEFAULT_BUFFER_DURATION_MS) div 1000;
  SetLength(FBuffer, FBufferSize);

  FActive := False;
  FIsSpeaking := False;
  FFileStream := TMemoryStream.Create;
  FMonitorState := msIdle;
  FSensitivity := 2000;
  FStopSensitivity := 1000; // NUEVO: Inicializar el umbral bajo

  // NUEVO: Inicializar los multiplicadores. Estos valores pueden ajustarse desde la UI.
  // 4.0 = Para empezar a hablar, el sonido debe ser 4 veces más fuerte que el ruido de fondo.
  // 2.0 = Para considerar que se ha detenido, el sonido debe caer por debajo de 2 veces el ruido de fondo.
  FSensitivityMultiplier := 4.0;
  FStopSensitivityMultiplier := 2.0;

  FCalibrationDurationSec := DEFAULT_CALIBRATION_DURATION_SEC;
  SetSilenceDuration(DEFAULT_SILENCE_DURATION_MS);
end;

destructor TAudioMonitor.Destroy;
begin
  Active := False;
  FFileStream.Free;
  FCS.Free;
  inherited;
end;

procedure TAudioMonitor.Start;
begin
{$IFDEF MSWINDOWS}
  StartCaptureAudioWindows;
{$ENDIF}
{$IFDEF ANDROID}
  FMonitorState := msRequestingPermission;
  PermissionsService.RequestPermissions([TPermission.RecordAudio], HandlePermissionRequest);
{$ENDIF}
end;

procedure TAudioMonitor.Stop;
begin
{$IFDEF MSWINDOWS}
  StopCaptureAudioWindows;
{$ENDIF}
{$IFDEF ANDROID}
  StopCaptureAudioAndroid;
{$ENDIF}
end;

procedure TAudioMonitor.SetActive(const Value: Boolean);
begin
  if Value <> FActive then
  begin
    FActive := Value;
    if FActive then
    begin
      FCS.Enter;
      try
        FMonitorState := msCalibrating;
        FCalibrationSamples := 0;
        FCalibrationAccumulator := 0;
        FIsSpeaking := False;
        if Length(FArrBuf) > 0 then
          FillChar(FArrBuf[0], Length(FArrBuf) * SizeOf(Boolean), 0);
        FFileStream.Clear;
      finally
        FCS.Leave;
      end;
      Start;
    end
    else
    begin
      Stop;
      FCS.Enter;
      try
        if FIsSpeaking then
        begin
          FIsSpeaking := False;
          TThread.Queue(nil, procedure begin DoChangeState(False); end);
        end;
        FMonitorState := msIdle;
      finally
        FCS.Leave;
      end;
    end;
  end;
end;

procedure TAudioMonitor.SetSilenceDuration(const Value: Integer);
var
  NewSize: Integer;
begin
  FSilenceDuration := Max(300, Value);
  NewSize := FSilenceDuration div DEFAULT_BUFFER_DURATION_MS;
  if NewSize < 2 then NewSize := 2;

  FCS.Enter;
  try
    SetLength(FArrBuf, NewSize);
    if Length(FArrBuf) > 0 then
      FillChar(FArrBuf[0], Length(FArrBuf) * SizeOf(Boolean), 0);
  finally
    FCS.Leave;
  end;
end;

procedure TAudioMonitor.ProcessAudioBuffer(const aBuffer: TBytes; aSize: Integer);
var
  Sum, CurrentLevel: Int64;
  NumSamples, I, TotalCalibrationSamplesNeeded, NoiseLevel: Integer;
  SampleValue: SmallInt;
begin
  if aSize = 0 then Exit;

  Sum := 0;
  NumSamples := aSize div (FBitsPerSample div 8);
  if NumSamples = 0 then Exit;

  for I := 0 to NumSamples - 1 do
  begin
    SampleValue := PSmallInt(@aBuffer[I * 2])^;
    Sum := Sum + Abs(SampleValue);
  end;
  CurrentLevel := Sum div NumSamples;

  FCS.Enter;
  try
    FSoundLevel := CurrentLevel;

    case FMonitorState of
      msCalibrating:
      begin
        FCalibrationAccumulator := FCalibrationAccumulator + CurrentLevel;
        Inc(FCalibrationSamples);
        TotalCalibrationSamplesNeeded := (FCalibrationDurationSec * 1000) div DEFAULT_BUFFER_DURATION_MS;

        if FCalibrationSamples >= TotalCalibrationSamplesNeeded then
        begin
          if FCalibrationSamples > 0 then
          begin
            NoiseLevel := FCalibrationAccumulator div FCalibrationSamples;
            // MODIFICADO: Calcular ambos umbrales usando los multiplicadores
            FSensitivity := Max(500, Round(NoiseLevel * FSensitivityMultiplier));
            FStopSensitivity := Max(250, Round(NoiseLevel * FStopSensitivityMultiplier));
            // Asegurarse de que el umbral de parada no sea mayor que el de inicio
            if FStopSensitivity >= FSensitivity then
              FStopSensitivity := FSensitivity - 1;
          end else
          begin
            FSensitivity := 1500;
            FStopSensitivity := 750;
          end;

          FMonitorState := msMonitoring;
          // MODIFICADO: Enviar ambos umbrales en el evento
          TThread.Queue(nil, procedure
                             begin
                               if Assigned(FOnCalibrated) then
                                 FOnCalibrated(Self, NoiseLevel, FSensitivity, FStopSensitivity);
                             end);
        end;
      end;
      msMonitoring:
      begin
        if FIsSpeaking then
          FFileStream.WriteBuffer(aBuffer, aSize);

        if Length(FArrBuf) > 0 then
        begin
          for I := 0 to High(FArrBuf) - 1 do
            FArrBuf[I] := FArrBuf[I + 1];

          // MODIFICADO: Lógica de doble umbral (Histéresis)
          if FIsSpeaking then
            // Si ya estamos hablando, solo necesitamos superar el umbral BAJO para seguir.
            FArrBuf[High(FArrBuf)] := (CurrentLevel > FStopSensitivity)
          else
            // Si estamos en silencio, necesitamos superar el umbral ALTO para empezar.
            FArrBuf[High(FArrBuf)] := (CurrentLevel > FSensitivity);
        end;
      end;
    end;
  finally
    FCS.Leave;
  end;

  TThread.Queue(nil, procedure begin if Assigned(FOnUpdate) then FOnUpdate(Self, CurrentLevel); end);

  if FMonitorState = msMonitoring then
    CalcSilencio;
end;

procedure TAudioMonitor.CalcSilencio;
var
  I: Integer;
  AllFalse: Boolean;
  PrevState, NewState: Boolean;
begin
  FCS.Enter;
  try
    PrevState := FIsSpeaking;
    NewState := FIsSpeaking;

    if (not FIsSpeaking) and (Length(FArrBuf) >= 2) and (FArrBuf[High(FArrBuf) - 1]) and (FArrBuf[High(FArrBuf)]) then
    begin
      NewState := True;
    end
    else if FIsSpeaking then
    begin
      AllFalse := True;
      for I := 0 to High(FArrBuf) do
      begin
        if FArrBuf[I] then
        begin
          AllFalse := False;
          Break;
        end;
      end;
      if AllFalse then
        NewState := False;
    end;

    if NewState <> PrevState then
    begin
      FIsSpeaking := NewState;
      TThread.Queue(nil, procedure begin DoChangeState(FIsSpeaking); end);
    end;
  finally
    FCS.Leave;
  end;
end;

procedure TAudioMonitor.DoChangeState(aIsSpeaking: Boolean);
var
  WavStream: TMemoryStream;
begin
  if aIsSpeaking then
  begin
    FCS.Enter;
    try
      FFileStream.Clear;
    finally
      FCS.Leave;
    end;
    if Assigned(FOnChangeState) then
      FOnChangeState(Self, True, nil);
  end
  else
  begin
    WavStream := TMemoryStream.Create;
    FCS.Enter;
    try
      ConvertPCMToWAV(FFileStream, WavStream);
    finally
      FCS.Leave;
    end;

    if Assigned(FOnChangeState) then
      FOnChangeState(Self, False, WavStream)
    else
      WavStream.Free;
  end;
end;

procedure TAudioMonitor.DoError(const aMessage: string);
begin
  FMonitorState := msError;
  FActive := False;
  Stop;
  TThread.Queue(nil, procedure begin if Assigned(FOnError) then FOnError(Self, aMessage); end);
end;

procedure TAudioMonitor.ConvertPCMToWAV(PCMStream, WAVStream: TMemoryStream);
var
  RiffHeader: TRiffHeader;
  FmtChunk: TFmtChunk;
  DataChunk: TDataChunk;
begin
  PCMStream.Position := 0;
  WAVStream.Clear;

  FmtChunk.Subchunk1ID    := 'fmt ';
  FmtChunk.Subchunk1Size  := 16;
  FmtChunk.AudioFormat    := 1; // WAVE_FORMAT_PCM
  FmtChunk.NumChannels    := FChannels;
  FmtChunk.SampleRate     := FSampleRate;
  FmtChunk.BitsPerSample  := FBitsPerSample;
  FmtChunk.BlockAlign     := FChannels * (FmtChunk.BitsPerSample div 8);
  FmtChunk.ByteRate       := FSampleRate * FmtChunk.BlockAlign;

  DataChunk.Subchunk2ID   := 'data';
  DataChunk.Subchunk2Size := PCMStream.Size;

  RiffHeader.ChunkID      := 'RIFF';
  RiffHeader.Format       := 'WAVE';
  RiffHeader.ChunkSize    := SizeOf(TFmtChunk) + SizeOf(TDataChunk) + 8 + PCMStream.Size;

  WAVStream.WriteBuffer(RiffHeader, SizeOf(RiffHeader));
  WAVStream.WriteBuffer(FmtChunk, SizeOf(FmtChunk));
  WAVStream.WriteBuffer(DataChunk, SizeOf(DataChunk));
  WAVStream.CopyFrom(PCMStream, 0);
  WAVStream.Position := 0;
end;

{$IFDEF MSWINDOWS}
procedure TAudioMonitor.StartCaptureAudioWindows;
var
  WaveFormat: TWaveFormatEx;
  Res: MMRESULT;
begin
  if not FActive then Exit;

  WaveFormat.wFormatTag := WAVE_FORMAT_PCM;
  WaveFormat.nChannels := FChannels;
  WaveFormat.nSamplesPerSec := FSampleRate;
  WaveFormat.wBitsPerSample := FBitsPerSample;
  WaveFormat.nBlockAlign := FChannels * (WaveFormat.wBitsPerSample div 8);
  WaveFormat.nAvgBytesPerSec := FSampleRate * WaveFormat.nBlockAlign;
  WaveFormat.cbSize := 0;

  Res := waveInOpen(@FhWaveIn, WAVE_MAPPER, @WaveFormat, DWORD_PTR(@AudioCallback), DWORD_PTR(Self), CALLBACK_FUNCTION);
  if Res <> MMSYSERR_NOERROR then
  begin
    DoError('Error al abrir dispositivo de audio: ' + IntToStr(Res));
    Exit;
  end;

  FillChar(FWaveHdr, SizeOf(FWaveHdr), 0);
  FWaveHdr.lpData := @FBuffer[0];
  FWaveHdr.dwBufferLength := FBufferSize;
  waveInPrepareHeader(FhWaveIn, @FWaveHdr, SizeOf(FWaveHdr));
  waveInAddBuffer(FhWaveIn, @FWaveHdr, SizeOf(FWaveHdr));

  Res := waveInStart(FhWaveIn);
  if Res <> MMSYSERR_NOERROR then
  begin
    waveInClose(FhWaveIn);
    DoError('Error al iniciar la captura de audio: ' + IntToStr(Res));
  end;
end;

procedure TAudioMonitor.StopCaptureAudioWindows;
begin
  if FhWaveIn <> 0 then
  begin
    waveInStop(FhWaveIn);
    waveInReset(FhWaveIn);
    waveInUnprepareHeader(FhWaveIn, @FWaveHdr, SizeOf(FWaveHdr));
    waveInClose(FhWaveIn);
    FhWaveIn := 0;
  end;
end;
{$ENDIF}

{$IFDEF ANDROID}
procedure TAudioMonitor.HandlePermissionRequest(Sender: TObject; const APermissions: TArray<string>; const AGrantResults: TArray<TPermissionStatus>);
begin
  if (Length(AGrantResults) > 0) and (AGrantResults[0] = TPermissionStatus.Granted) then
    StartCaptureAudioAndroid
  else
    DoError('Permiso para grabar audio denegado.');
end;

procedure TAudioMonitor.StartCaptureAudioAndroid;
var
  AudioSource, ChannelConfig, AudioFormat, MinBufferSize: Integer;
begin
  if not FActive then Exit;
  try
    AudioSource := TJMediaRecorder_AudioSource.JavaClass.MIC;
    ChannelConfig := TJAudioFormat.JavaClass.CHANNEL_IN_MONO;
    AudioFormat := TJAudioFormat.JavaClass.ENCODING_PCM_16BIT;
    MinBufferSize := TJAudioRecord.JavaClass.getMinBufferSize(FSampleRate, ChannelConfig, AudioFormat);

    if FBufferSize < MinBufferSize then
      FBufferSize := MinBufferSize;
    SetLength(FBuffer, FBufferSize);

    FAudioRecord := TJAudioRecord.JavaClass.init(AudioSource, FSampleRate, ChannelConfig, AudioFormat, FBufferSize);
    if FAudioRecord.getState <> TJAudioRecord.JavaClass.STATE_INITIALIZED then
    begin
      DoError('No se pudo inicializar AudioRecord.');
      Exit;
    end;

    if Assigned(FCaptureThread) then
    begin
      FCaptureThread.Terminate;
      FCaptureThread.WaitFor;
      FCaptureThread := nil;
    end;

    FCaptureThread := TThread.CreateAnonymousThread(AndroidCaptureLoop);
    FCaptureThread.FreeOnTerminate := True;
    FAudioRecord.startRecording;
    FCaptureThread.Start;
  except
    on E: Exception do
      DoError('Excepción al iniciar captura en Android: ' + E.Message);
  end;
end;

procedure TAudioMonitor.StopCaptureAudioAndroid;
begin
  if Assigned(FCaptureThread) then
  begin
    FCaptureThread.Terminate;
    FCaptureThread := nil;
  end;
  if Assigned(FAudioRecord) then
  begin
    if FAudioRecord.getRecordingState = TJAudioRecord.JavaClass.RECORDSTATE_RECORDING then
      FAudioRecord.stop;
    if FAudioRecord.getState = TJAudioRecord.JavaClass.STATE_INITIALIZED then
      FAudioRecord.release;
    FAudioRecord := nil;
  end;
end;

procedure TAudioMonitor.AndroidCaptureLoop;
var
  JBuffer: TJavaArray<Byte>;
  BytesRead: Integer;
begin
  JBuffer := TJavaArray<Byte>.Create(FBufferSize);
  try
    while not TThread.CheckTerminated do
    begin
      if not Assigned(FAudioRecord) then Break;
      BytesRead := FAudioRecord.read(JBuffer, 0, FBufferSize);
      if BytesRead > 0 then
      begin
        JNI.GetByteArrayRegion(JBuffer.GetObjectID, 0, BytesRead, PByte(FBuffer));
        ProcessAudioBuffer(FBuffer, BytesRead);
      end
      else if BytesRead < 0 then
      begin
        DoError('Error de lectura de AudioRecord: ' + IntToStr(BytesRead));
        Break;
      end;
    end;
  finally
    JBuffer := nil;
  end;
end;
{$ENDIF}

end.

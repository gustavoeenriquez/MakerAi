// IT License
//
// Copyright (c) <year> <copyright holders>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// o use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// HE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// Nombre: Gustavo Enríquez
// Redes Sociales:
// - Email: gustavoeenriquez@gmail.com
// - Telegram: +57 3128441700
// - LinkedIn: https://www.linkedin.com/in/gustavo-enriquez-3937654a/
// - Youtube: https://www.youtube.com/@cimamaker3945
// - GitHub: https://github.com/gustavoeenriquez/

unit uMakerAi.Utils.Python;

interface
uses
  PythonEngine, System.SysUtils, System.Generics.Collections, System.Classes;

Type
  // Tipo para almacenar parámetros con nombre y valor
  TPythonParam = record
    Name: string;
    Value: Variant;
  end;

  // Array dinámico de parámetros
  TPythonParams = TArray<TPythonParam>;

  TUtilsPython = Class
    Private
    Protected
    Public
      // Función original sin parámetros
      Class function ExecuteScript(Script: String): String; overload;

      // Sobrecarga con parámetros usando array dinámico
      Class function ExecuteScript(Script: String; const Params: TPythonParams): String; overload;

      // Sobrecarga con parámetros usando TDictionary (más fácil de usar)
      Class function ExecuteScript(Script: String; const Params: TDictionary<string, Variant>): String; overload;

      class function ExecuteScript(Script: String; const Params: TStrings): String; overload;

      // Función auxiliar para crear parámetros fácilmente
      Class function CreateParam(const Name: string; const Value: Variant): TPythonParam;

      // Función auxiliar para convertir variant a string Python
      Class function VariantToPythonString(const Value: Variant): string;


  End;

var
  GlPythonEngine: TPythonEngine;

procedure InitializePythonEngine;
Function GetPythonEngine(DllName: String = 'python310.dll'): TPythonEngine;

implementation

uses
  System.Variants;

Function GetPythonEngine(DllName: String): TPythonEngine;
Begin
  if not Assigned(GlPythonEngine) then
  begin
    GlPythonEngine := TPythonEngine.Create(nil);
  end;
  GlPythonEngine.DllName := DllName; // Asegúrate de usar la versión correcta de Python
  If Not GlPythonEngine.Initialized then
    GlPythonEngine.LoadDll;
  Result := GlPythonEngine;
End;

procedure InitializePythonEngine;
begin
  if not Assigned(GlPythonEngine) then
  begin
    GlPythonEngine := TPythonEngine.Create(nil);
  end;
end;

{ TUtilsPython }

// Función original sin cambios
class function TUtilsPython.ExecuteScript(Script: String): String;
var
  PyEngine : TPythonEngine;
  PyModule: TPythonModule;
  PyResult: PPyObject;
begin
  PyEngine := GetPythonEngine; //Obtiene el engine global
  try
    // Crear el módulo de Python
    PyModule := TPythonModule.Create(nil);
    PyModule.Engine := PyEngine;
    PyModule.ModuleName := 'mymodule';
    // Ejecutar el script de Python
    PyEngine.ExecString(Script);
    // Obtener el resultado de la ejecución
    PyResult := PyEngine.EvalString('result');
    // Convertir el resultado a una cadena
    Result := PyEngine.PyObjectAsString(PyResult);
    // Decrementar la referencia del objeto Python
    PyEngine.Py_DecRef(PyResult);
  Except
    On E: Exception do
    Begin
      Result := E.Message +sLineBreak+'Recuerda que todos los script deben retornar algo en una variable llamada Result';
      Raise;
    End;
  end;
end;

// Sobrecarga con array de parámetros
class function TUtilsPython.ExecuteScript(Script: String; const Params: TPythonParams): String;
var
  PyEngine: TPythonEngine;
  PyModule: TPythonModule;
  PyResult: PPyObject;
  FullScript: string;
  i: Integer;
begin
  PyEngine := GetPythonEngine;
  try
    // Crear el módulo de Python
    PyModule := TPythonModule.Create(nil);
    try
      PyModule.Engine := PyEngine;
      PyModule.ModuleName := 'mymodule';

      // Construir el script completo con la asignación de variables
      FullScript := '';

      // Agregar las asignaciones de parámetros al inicio del script
      for i := Low(Params) to High(Params) do
      begin
        FullScript := FullScript + Params[i].Name + ' = ' + VariantToPythonString(Params[i].Value) + sLineBreak;
      end;

      // Agregar el script principal
      FullScript := FullScript + sLineBreak + Script;

      // Ejecutar el script completo
      PyEngine.ExecString(FullScript);

      // Obtener el resultado de la ejecución
      PyResult := PyEngine.EvalString('result');

      // Convertir el resultado a una cadena
      Result := PyEngine.PyObjectAsString(PyResult);

      // Decrementar la referencia del objeto Python
      PyEngine.Py_DecRef(PyResult);

    finally
      PyModule.Free;
    end;

  Except
    On E: Exception do
    Begin
      Result := E.Message + sLineBreak + 'Recuerda que todos los script deben retornar algo en una variable llamada result';
      Raise;
    End;
  end;
end;

// Sobrecarga con TDictionary (más fácil de usar)
class function TUtilsPython.ExecuteScript(Script: String; const Params: TDictionary<string, Variant>): String;
var
  ParamsArray: TPythonParams;
  Key: string;
  i: Integer;
begin
  // Convertir el dictionary a array de parámetros
  SetLength(ParamsArray, Params.Count);
  i := 0;
  for Key in Params.Keys do
  begin
    ParamsArray[i].Name := Key;
    ParamsArray[i].Value := Params[Key];
    Inc(i);
  end;

  // Llamar a la sobrecarga con array
  Result := ExecuteScript(Script, ParamsArray);
end;

// Función auxiliar para crear parámetros
class function TUtilsPython.CreateParam(const Name: string; const Value: Variant): TPythonParam;
begin
  Result.Name := Name;
  Result.Value := Value;
end;

// Función auxiliar para convertir Variant a string Python
class function TUtilsPython.VariantToPythonString(const Value: Variant): string;
begin
  case VarType(Value) of
    varEmpty, varNull:
      Result := 'None';
    varBoolean:
      if Value then
        Result := 'True'
      else
        Result := 'False';
    varByte, varShortInt, varWord, varSmallint, varInteger, varLongWord, varInt64, varUInt64:
      Result := IntToStr(Value);
    varSingle, varDouble, varCurrency:
      Result := StringReplace(FloatToStr(Value), ',', '.', [rfReplaceAll]);
    varString, varUString, varOleStr:
      Result := '''' + StringReplace(StringReplace(VarToStr(Value), '\', '\\', [rfReplaceAll]), '''', '\''', [rfReplaceAll]) + '''';
  else
    // Para otros tipos, intentar convertir a string
    Result := '''' + StringReplace(StringReplace(VarToStr(Value), '\', '\\', [rfReplaceAll]), '''', '\''', [rfReplaceAll]) + '''';
  end;
end;

class function TUtilsPython.ExecuteScript(Script: String; const Params: TStrings): String;
var
  i: Integer;
  ParamName, ParamValue: String;
  ProcessedScript: String;
begin
  Result := '';
  ProcessedScript := Script;

  try
    // Procesar cada parámetro en la lista
    if Assigned(Params) then
    begin
      for i := 0 to Params.Count - 1 do
      begin
        // Verificar que el parámetro tenga el formato correcto ParamName=ParamValue
        if Pos('=', Params[i]) > 0 then
        begin
          ParamName := Trim(Copy(Params[i], 1, Pos('=', Params[i]) - 1));
          ParamValue := Trim(Copy(Params[i], Pos('=', Params[i]) + 1, Length(Params[i])));

          // Reemplazar todas las ocurrencias del parámetro en el script
          // Puedes usar diferentes formatos como {{ParamName}}, :ParamName, etc.
          ProcessedScript := StringReplace(ProcessedScript, '{{' + ParamName + '}}', ParamValue, [rfReplaceAll, rfIgnoreCase]);
          ProcessedScript := StringReplace(ProcessedScript, ':' + ParamName, ParamValue, [rfReplaceAll, rfIgnoreCase]);
          ProcessedScript := StringReplace(ProcessedScript, '$' + ParamName, ParamValue, [rfReplaceAll, rfIgnoreCase]);
        end;
      end;
    end;

    // Aquí es donde ejecutarías el script procesado
    // Dependiendo del tipo de script (SQL, PowerShell, Batch, etc.)
    Result := ExecuteScript(ProcessedScript);

  except
    on E: Exception do
    begin
      Result := 'Error: ' + E.Message;
    end;
  end;
end;


initialization
  InitializePythonEngine;

finalization
  FreeAndNil(GlPythonEngine);

end.

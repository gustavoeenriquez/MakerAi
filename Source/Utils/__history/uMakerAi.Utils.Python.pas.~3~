// IT License
//
// ... (Tus comentarios de licencia y autoría) ...
//
// Versión Refactorizada y Corregida:
// - Se utiliza PyEngine.ExecString en lugar de un método inexistente en TPythonModule.
// - Se crea un diccionario temporal para actuar como el espacio de nombres (namespace) del script.
// - Se utilizan los métodos de instancia PyEngine.VarToPyObject y PyEngine.PyObjectAsVariant.
// - Se eliminan las referencias a TPythonModule que no eran necesarias para este enfoque.

unit uMakerAi.Utils.Python;

interface
uses
  PythonEngine, System.SysUtils, System.Generics.Collections, System.Classes, System.Variants;

Type
  TPythonParam = record
    Name: string;
    Value: Variant;
  end;

  TPythonParams = TArray<TPythonParam>;

  TUtilsPython = Class
  private
    class function GenerateWrapperScript(const UserScript: string; const ParamNames: TStringList): string;
  Public
    Class function ExecuteScript(Script: String): String; overload;
    Class function ExecuteScript(Script: String; const Params: TDictionary<string, Variant>): String; overload;
    class function ExecuteScript(Script: String; const Args: array of Variant): String; overload;
    Class function ExecuteScript(Script: String; const Params: TPythonParams): String; overload;
    class function ExecuteScript(Script: String; const Params: TStrings): String; overload;
    Class function CreateParam(const Name: string; const Value: Variant): TPythonParam;
    Class function VariantToPythonString(const Value: Variant): string;
  End;

var
  GlPythonEngine: TPythonEngine;

procedure InitializePythonEngine;
Function GetPythonEngine(DllName: String = 'python310.dll'): TPythonEngine;

implementation

// *** CORREGIDO ***: Ya no se necesita PythonVersions aquí, TPythonEngine tiene los métodos.

{ Gestión del Motor de Python }
Function GetPythonEngine(DllName: String): TPythonEngine;
Begin
  if not Assigned(GlPythonEngine) then
  begin
    GlPythonEngine := TPythonEngine.Create(nil);
  end;
  GlPythonEngine.DllName := DllName;
  If Not GlPythonEngine.Initialized then
    GlPythonEngine.LoadDll;
  Result := GlPythonEngine;
End;

procedure InitializePythonEngine;
begin
  if not Assigned(GlPythonEngine) then
  begin
    GlPythonEngine := TPythonEngine.Create(nil);
  end;
end;

{ TUtilsPython }

class function TUtilsPython.GenerateWrapperScript(const UserScript: string; const ParamNames: TStringList): string;
var
  WrapperScript: TStringBuilder;
  IndentedScript: string;
begin
  WrapperScript := TStringBuilder.Create;
  try
    IndentedScript := StringReplace(UserScript, sLineBreak, sLineBreak + '    ', [rfReplaceAll]);
    WrapperScript.Append('def __delphi_script_runner(');
    if (ParamNames <> nil) and (ParamNames.Count > 0) then
      WrapperScript.Append(ParamNames.CommaText);
    WrapperScript.AppendLine('):');
    WrapperScript.AppendLine('    ' + IndentedScript);
    WrapperScript.AppendLine('');
    WrapperScript.AppendLine('    try:');
    WrapperScript.AppendLine('        return result');
    WrapperScript.AppendLine('    except NameError:');
    WrapperScript.AppendLine('        return None');
    Result := WrapperScript.ToString;
  finally
    WrapperScript.Free;
  end;
end;

class function TUtilsPython.ExecuteScript(Script: String): String;
var
  PyEngine : TPythonEngine;
  PyResult: PPyObject;
begin
  PyEngine := GetPythonEngine;
  try
    // *** CORREGIDO ***: Usar el método de instancia correcto
    Result := PyEngine.EvalStringAsStr(Script);
  except
    {on E: EPythonError do
    begin
      Result := 'Error en script: ' + E.Message + sLineBreak +
                'Recuerde que el script debe asignar un valor a la variable "result".';
      // No es necesario relanzar si queremos que la función devuelva el error como string.
      // Si quieres que la aplicación se detenga, usa: raise;
    end
    }

    on E: Exception do
    begin
      Result := 'Error inesperado: ' + E.Message;
      // raise;
    end;
  end;
end;


class function TUtilsPython.ExecuteScript(Script: String; const Params: TDictionary<string, Variant>): String;
var
  PyEngine: TPythonEngine;
  ParamNames: TStringList;
  WrapperScript: string;
  PyFunc, PyKwArgs, PyResult, PyValue, PyArgsTuple, PyModuleDict: PPyObject;
  key: string;
begin
  if (Params = nil) or (Params.Count = 0) then
  begin
    Result := ExecuteScript(Script);
    Exit;
  end;

  PyEngine := GetPythonEngine;
  ParamNames := TStringList.Create;
  PyFunc      := nil;
  PyKwArgs    := nil;
  PyResult    := nil;
  PyValue     := nil;
  PyArgsTuple := nil;
  PyModuleDict := nil;

  try
    // *** CORREGIDO ***: Crear un diccionario que actuará como nuestro espacio de nombres.
    PyModuleDict := PyEngine.PyDict_New();
    if not Assigned(PyModuleDict) then
        raise EPySystemError.Create('No se pudo crear el diccionario de espacio de nombres.');

    // 1. Preparar nombres de parámetros y generar el wrapper
    for key in Params.Keys do
      ParamNames.Add(key);

    WrapperScript := GenerateWrapperScript(Script, ParamNames);

    // 2. Ejecutar el wrapper en el contexto de nuestro diccionario.
    // *** CORREGIDO ***: Llamar a ExecString desde la instancia del motor,
    // pasándole nuestro diccionario como 'globals' y 'locals'.
    PyEngine.ExecString(AnsiString(WrapperScript), PyModuleDict, PyModuleDict);
    PyEngine.CheckError; // Verificar si hubo un error de compilación en el script

    // 3. Obtener una referencia a la función desde nuestro diccionario.
    PyFunc := PyEngine.PyDict_GetItemString(PyModuleDict, '__delphi_script_runner');
    if not Assigned(PyFunc) then
      raise EPySystemError.Create('Fallo al crear la función wrapper de Python.');
    PyEngine.Py_IncRef(PyFunc); // GetItemString devuelve una referencia prestada, la convertimos en propia.

    // 4. Preparar los parámetros con nombre (kwargs)
    PyKwArgs := PyEngine.PyDict_New();
    for key in Params.Keys do
    begin
      // *** CORREGIDO ***: Usar el método de instancia VarToPyObject.
      PyValue := PyEngine.VarToPyObject(Params.Values[key]);
      PyEngine.PyDict_SetItemString(PyKwArgs, PAnsiChar(AnsiString(key)), PyValue);
      PyEngine.Py_DecRef(PyValue);
    end;

    // 5. Llamar a la función.
    PyArgsTuple := PyEngine.PyTuple_New(0);
    PyResult := PyEngine.PyObject_Call(PyFunc, PyArgsTuple, PyKwArgs);
    PyEngine.CheckError;

    // 6. Procesar el resultado.
    if Assigned(PyResult) and (PyResult <> PyEngine.Py_None) then
      // *** CORREGIDO ***: Usar el método de instancia PyObjectAsString.
      Result := PyEngine.PyObjectAsString(PyResult)
    else
      Result := '';
  finally
    PyEngine.Py_XDecRef(PyFunc);
    PyEngine.Py_XDecRef(PyArgsTuple);
    PyEngine.Py_XDecRef(PyKwArgs);
    PyEngine.Py_XDecRef(PyResult);
    PyEngine.Py_XDecRef(PyModuleDict); // Liberar nuestro diccionario
    ParamNames.Free;
  end;
end;

class function TUtilsPython.ExecuteScript(Script: String; const Args: array of Variant): String;
var
  PyEngine: TPythonEngine;
  WrapperScript: string;
  ParamNames: TStringList;
  PyFunc, PyArgsTuple, PyResult, PyValue, PyModuleDict: PPyObject;
  i: Integer;
begin
  if Length(Args) = 0 then
  begin
    Result := ExecuteScript(Script);
    Exit;
  end;

  PyEngine := GetPythonEngine;
  ParamNames := TStringList.Create;
  PyFunc      := nil;
  PyArgsTuple := nil;
  PyResult    := nil;
  PyValue     := nil;
  PyModuleDict := nil;

  try
    // *** CORREGIDO ***: Crear diccionario de espacio de nombres.
    PyModuleDict := PyEngine.PyDict_New();

    // 1. Generar nombres de parámetros posicionales y el wrapper.
    for i := 0 to High(Args) do
      ParamNames.Add('arg' + IntToStr(i + 1));
    WrapperScript := GenerateWrapperScript(Script, ParamNames);

    // 2. Ejecutar el wrapper en el contexto de nuestro diccionario.
    // *** CORREGIDO ***
    PyEngine.ExecString(AnsiString(WrapperScript), PyModuleDict, PyModuleDict);
    PyEngine.CheckError;

    // 3. Obtener referencia a la función.
    PyFunc := PyEngine.PyDict_GetItemString(PyModuleDict, '__delphi_script_runner');
    if not Assigned(PyFunc) then
      raise EPySystemError.Create('Fallo al crear la función wrapper de Python.');
    PyEngine.Py_IncRef(PyFunc);

    // 4. Preparar los parámetros posicionales (args) en una Tupla.
    PyArgsTuple := PyEngine.PyTuple_New(Length(Args));
    for i := 0 to High(Args) do
    begin
      // *** CORREGIDO ***: Usar el método de instancia.
      PyValue := PyEngine.VarToPyObject(Args[i]);
      PyEngine.PyTuple_SetItem(PyArgsTuple, i, PyValue); // SetItem roba la referencia.
    end;

    // 5. Llamar a la función.
    PyResult := PyEngine.PyObject_CallObject(PyFunc, PyArgsTuple);
    PyEngine.CheckError;

    // 6. Procesar el resultado.
    if Assigned(PyResult) and (PyResult <> PyEngine.Py_None) then
      // *** CORREGIDO ***: Usar el método de instancia.
      Result := PyEngine.PyObjectAsString(PyResult)
    else
      Result := '';
  finally
    PyEngine.Py_XDecRef(PyFunc);
    PyEngine.Py_XDecRef(PyArgsTuple);
    PyEngine.Py_XDecRef(PyResult);
    PyEngine.Py_XDecRef(PyModuleDict);
    ParamNames.Free;
  end;
end;

class function TUtilsPython.ExecuteScript(Script: String; const Params: TPythonParams): String;
var
  ParamsDict: TDictionary<string, Variant>;
  i: Integer;
begin
  ParamsDict := TDictionary<string, Variant>.Create;
  try
    for i := Low(Params) to High(Params) do
      ParamsDict.Add(Params[i].Name, Params[i].Value);
    Result := ExecuteScript(Script, ParamsDict);
  finally
    ParamsDict.Free;
  end;
end;

class function TUtilsPython.ExecuteScript(Script: String; const Params: TStrings): String;
var
  i: Integer;
  ParamName, ParamValue: String;
  ProcessedScript: String;
begin
  // ADVERTENCIA: Este método de reemplazo de texto es inseguro y propenso a errores.
  Result := '';
  ProcessedScript := Script;
  try
    if Assigned(Params) then
    begin
      for i := 0 to Params.Count - 1 do
      begin
        if Pos('=', Params[i]) > 0 then
        begin
          ParamName := Trim(Copy(Params[i], 1, Pos('=', Params[i]) - 1));
          ParamValue := Trim(Copy(Params[i], Pos('=', Params[i]) + 1, Length(Params[i])));
          ProcessedScript := StringReplace(ProcessedScript, '{{' + ParamName + '}}', ParamValue, [rfReplaceAll, rfIgnoreCase]);
          ProcessedScript := StringReplace(ProcessedScript, ':' + ParamName, ParamValue, [rfReplaceAll, rfIgnoreCase]);
          ProcessedScript := StringReplace(ProcessedScript, '$' + ParamName, ParamValue, [rfReplaceAll, rfIgnoreCase]);
        end;
      end;
    end;
    Result := ExecuteScript(ProcessedScript);
  except
    on E: Exception do
    begin
      Result := 'Error en script con TStrings: ' + E.Message;
      raise;
    end;
  end;
end;

class function TUtilsPython.CreateParam(const Name: string; const Value: Variant): TPythonParam;
begin
  Result.Name := Name;
  Result.Value := Value;
end;

class function TUtilsPython.VariantToPythonString(const Value: Variant): string;
begin
  // NOTA: Esta función se mantiene por compatibilidad. Ya no es usada por los métodos seguros.
  case VarType(Value) of
    varEmpty, varNull: Result := 'None';
    varBoolean: if Value then Result := 'True' else Result := 'False';
    varByte, varShortInt, varWord, varSmallint, varInteger, varLongWord, varInt64, varUInt64:
      Result := IntToStr(Value);
    varSingle, varDouble, varCurrency:
      Result := StringReplace(FloatToStr(Value), ',', '.', [rfReplaceAll]);
    varString, varUString, varOleStr:
      Result := '''' + StringReplace(StringReplace(VarToStr(Value), '\', '\\', [rfReplaceAll]), '''', '\''', [rfReplaceAll]) + '''';
  else
    Result := '''' + StringReplace(StringReplace(VarToStr(Value), '\', '\\', [rfReplaceAll]), '''', '\''', [rfReplaceAll]) + '''';
  end;
end;

initialization
  InitializePythonEngine;

finalization
  FreeAndNil(GlPythonEngine);

end.
